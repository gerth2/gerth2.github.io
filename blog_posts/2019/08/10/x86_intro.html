<!DOCTYPE html>
<html lang="en">

    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [['$','$'], ['\\(','\\)']],
          processEscapes: true
        }
      });
      </script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>
  
      <script src="https://d3js.org/d3.v3.js"></script>
      <script src="/assets/js/function-plot.js"></script><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.6.1 -->
<title>x86 Assembly Introduction | Tricking Rocks to Think</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="x86 Assembly Introduction" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="“It is well-known that the x86 instruction set is baroque, overcomplicated, and redundantly redundant.” - Stephen Dolan" />
<meta property="og:description" content="“It is well-known that the x86 instruction set is baroque, overcomplicated, and redundantly redundant.” - Stephen Dolan" />
<link rel="canonical" href="/blog_posts/2019/08/10/x86_intro.html" />
<meta property="og:url" content="/blog_posts/2019/08/10/x86_intro.html" />
<meta property="og:site_name" content="Tricking Rocks to Think" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2019-08-10T09:30:40-05:00" />
<script type="application/ld+json">
{"mainEntityOfPage":{"@type":"WebPage","@id":"/blog_posts/2019/08/10/x86_intro.html"},"url":"/blog_posts/2019/08/10/x86_intro.html","description":"“It is well-known that the x86 instruction set is baroque, overcomplicated, and redundantly redundant.” - Stephen Dolan","headline":"x86 Assembly Introduction","@type":"BlogPosting","dateModified":"2019-08-10T09:30:40-05:00","datePublished":"2019-08-10T09:30:40-05:00","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="/feed.xml" title="Tricking Rocks to Think" /></head>
<body>

    <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico" ><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">Tricking Rocks to Think</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">About</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">x86 Assembly Introduction</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2019-08-10T09:30:40-05:00" itemprop="datePublished">Aug 10, 2019
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <p><em>“It is well-known that the x86 instruction set is baroque, overcomplicated, and redundantly redundant.” - <a href="https://github.com/stedolan">Stephen Dolan</a></em></p>

<h2 id="introduction">Introduction</h2>

<p>In our grand arc of introductory topics, this sadly is nearing the end.</p>

<p>We now most of the basic required components to analyze how a high-level C code program can get translated into 1’s and 0’s on a processor. One last piece of the puzzle - we’ll introduce a particular assembly language - x86 - and then show how C code constructs are implemented using the assembly language.</p>

<h2 id="x86">x86</h2>

<p><em>x86</em> (pronounced “ecks - eighty - six”) is the name for one of the most ubiquitous processor architectures in the world today. x86 is very old, dating back to some of the initial processors that Intel manufactured. Intel has been very rigirous about keeping it backward compatible, so the full specification carries most of the legacy functionality of processors manufactured 20 to 30 years ago. This makes the full specification around 2900 pages long - not exactly light reading.</p>

<p>When learning about x86, it’s better to start not with the actual documentation, but one of <a href="https://www.cs.virginia.edu/~evans/cs216/guides/x86.html">the many helpful guides</a> out there. <a href="https://en.wikibooks.org/wiki/X86_Assembly/X86_Architecture">Here is another good one.</a></p>

<h3 id="the-basics">The Basics</h3>

<p>In order to introduce how your C code gets executed on a processor, we’re going to start by a basic overview of how programming in x86 assembly works.</p>

<p>As a basic review, recall that when we write assembly code, there is a <em>one to one</em> mapping from assembly instructions to bits that go into and out of the processor. Whenever we describe some particular <em>assembly instruction</em> in this post, just remember that you can go straight from that to bits.</p>

<p><em>Which bits</em> is described within the <a href="https://www.intel.com/content/dam/www/public/us/en/documents/manuals/64-ia-32-architectures-software-developer-instruction-set-reference-manual-325383.pdf">x86 software developer’s reference manual</a>. This behemoth of documentation describes, in great detail, the operation of every assembly instruction, and how to encode it into bits. Diagrams like this one explain the mapping:</p>

<p><img src="/assets/intel_inst_format.png" alt="Intel instruction set bit format" /></p>

<p>Which, as you are probably guessing, is not the most straightforward of methodologies. It’s totally feasable to figure out though, but that figuring will be left as an exerices to the user. It’s all there in that manual though, I promise.</p>

<p>Again though, at least for the sake of this post, keep in mind that given an assembly instruction, you can get bits which go into a processor. All such that we can define what the starting layout of 1’s and 0’s in our RAM looks like:</p>

<p><img src="/assets/controlUnitMemoryLayout.png" alt="Control Unit RAM" /></p>

<p>When writing assembly code, what you are really doing is defining the bits that will go into memory as the <em>stored program</em>, eventually executed by a processor. Once you have the right set of bits, you just have to load them into memory at just the right spot, then fire up the processor. It will pick the first address, and start running your program from the beginning.</p>

<p><em>How</em> these instructions are loaded into Memory will have to be a future post, as it’s beyond the scope of this discussion. For now, I promise, there <em>is</em> a way to make it happen, and it does happen.</p>

<h4 id="setting-aside-memory-for-storage">Setting Aside Memory for Storage</h4>

<p>In addition to the actual instructions to run, you’ll also generally want to reserve memory locations to store values. Here’s a brief hint of where we’re going - remember variables from C syntax? Any time you have a variable, you’ll need some memory to store it. When writing x86 assembly, you can mark off a sets of bits for usage as variables:</p>

<div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">section</span> <span class="p">.</span><span class="n">data</span>
<span class="n">myVariable</span>  <span class="kt">DB</span> <span class="mi">42</span>
<span class="n">myOtherVariable</span> <span class="kt">DW</span> <span class="mi">25</span>
</code></pre></div></div>

<p>The <code class="highlighter-rouge">.data</code> directive tells the assembler that the things which follow are memory locations for variables, not code. The name of the variable comes first, followed by some string like <code class="highlighter-rouge">DB</code> or <code class="highlighter-rouge">DW</code> to indicate <em>how many</em> bytes the variable occupies. <code class="highlighter-rouge">DB</code> is one byte, <code class="highlighter-rouge">DW</code> is two, <code class="highlighter-rouge">DD</code> is four… others exist. The final thing can be optional, and dictates what the memory is to be set to prior to any code running. In this case, <code class="highlighter-rouge">myVariable</code> gets set to <a href="https://en.wikipedia.org/wiki/Phrases_from_The_Hitchhiker%27s_Guide_to_the_Galaxy#Answer_to_the_Ultimate_Question_of_Life,_the_Universe,_and_Everything_(42)">The Answer to the Ultimate Question of Life, the Universe, and Everything</a>, while <code class="highlighter-rouge">myOtherVariable</code> gets set to 25.</p>

<p>It’s worthwhile to note that when working with these labeled memory locations, the name (eg, <code class="highlighter-rouge">myVariable</code>) refers to the actual memory <em>address</em>, while putting it in brackets (eg, <code class="highlighter-rouge">[myVariable]</code>) refers to the <em>value at that address</em>. When working with instructions, sometimes the assembly instruction needs a memory address, and other times it needs a value. Use each form as needed.</p>

<p>As in all programming languages worth their salt, it is also possible to write comments in your assembly code.</p>

<div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">;---------------------------------------------------</span>
<span class="c">; Herp Derp this is where the global variables go!</span>
<span class="c">; Aren't comments the best?</span>
<span class="c">;---------------------------------------------------</span>
<span class="kr">section</span> <span class="p">.</span><span class="n">data</span>
<span class="n">myVariable</span>  <span class="kt">DB</span> <span class="mi">42</span>
<span class="n">myOtherVariable</span> <span class="kt">DW</span> <span class="mi">25</span>
</code></pre></div></div>

<h4 id="registers">Registers</h4>

<p>We’ll now attempt to describe the General Purpose registers of interest to us in x86 processor architecture.</p>

<p><img src="/assets/controlUnitRegisters.png" alt="Control Unit GPRs" /></p>

<p>Accessing memory addresses can be slow, so for rapid access of heavily-manipulated values, it’s common place to use a <em>general purpose</em> register to store the quantity. Physically located close to the center of the processor and implemented with high-speed circuitry, these registers are limited in quantity but abundant in speed and capiability. Additionally, some assembly instructions can only work with certain registers, so it’s required to populate the register first before running the restricted assembly instruction.</p>

<p>There are a lof these on the x86 architecture, but there’s just a handful we’ll focus on for now. Their names are:</p>

<ol>
  <li><code class="highlighter-rouge">EAX</code></li>
  <li><code class="highlighter-rouge">EBX</code></li>
  <li><code class="highlighter-rouge">ECX</code></li>
  <li><code class="highlighter-rouge">EDX</code></li>
</ol>

<p>These four in particular can be used to store pretty much whatever values you want. Other registers have more restrictions, but these are the most general-purpose of all the general-purpose registers.</p>

<h4 id="memory-and-register-transfer">Memory and Register Transfer</h4>

<p>To do anything useful, we’ll first want to know how to assign and move data values around in the processor.</p>

<p><img src="/assets/controlUnitMemoryOps.png" alt="Control Unit Memory Operations" /></p>

<p><code class="highlighter-rouge">mov</code> is the first assembly instruction we will cover. <code class="highlighter-rouge">mov</code> stands for <em>move</em>. It’s the true workhorse of the x86 assembly language. <sup id="fnref:1"><a href="#fn:1" class="footnote">1</a></sup> It’s primary job - move values from one place to another. Fundamentally the syntax is:</p>

<p><code class="highlighter-rouge">mov &lt;dst&gt; &lt;src&gt;</code></p>

<p>It can move constant values into registers or memory, move between registers, or move between registers and memory:</p>
<div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">; ----------------------------------------------------------------------------</span>
<span class="c">; sample.asm</span>
<span class="c">; ----------------------------------------------------------------------------</span>

    <span class="kr">global</span>  <span class="n">_main</span>

<span class="c">; ----------------------------------------------------------------------------</span>
<span class="c">; Code Starts Here</span>

<span class="kr">section</span> <span class="p">.</span><span class="n">text</span>

<span class="n">_main</span><span class="o">:</span>
    <span class="k">mov</span> <span class="n">EAX</span><span class="p">,</span> <span class="p">[myVariable]</span>            <span class="c">; Move the value at myVariable into EAX </span>
                                     <span class="c">; EAX now contains 42</span>
    <span class="k">mov</span> <span class="n">EBX</span><span class="p">,</span> <span class="mi">1234</span>                    <span class="c">; Move the constant value 1234 into EBX</span>
                                     <span class="c">; EBX now contains 1234</span>
    <span class="k">mov</span> <span class="n">EDX</span><span class="p">,</span> <span class="n">EAX</span>                     <span class="c">; Load EDX with the present value of EAX</span>
                                     <span class="c">; EDX is now also 42</span>
    <span class="k">mov</span> <span class="n">dword</span> <span class="p">[myOtherVariable],</span> <span class="mi">25</span>  <span class="c">; Load the constant value 25 into </span>
                                     <span class="c">;   all 32 of the bits of myOtherVariable</span>
                                     <span class="c">; The memory allocated at label </span>
                                     <span class="c">;   "myOtherVariable" now has value 25</span>
    <span class="k">mov</span> <span class="n">ECX</span><span class="p">,</span> <span class="p">[myOtherVariable]</span>       <span class="c">; Load ECX with the value from memory </span>
                                     <span class="c">;   labeled "myOtherVariable"</span>
                                     <span class="c">; ECX is now also 25</span>

    <span class="c">; We are done executing - return control to the operating system</span>
    <span class="k">retn</span> 

<span class="c">; ----------------------------------------------------------------------------</span>
<span class="c">; Global Variables</span>

<span class="kr">section</span> <span class="p">.</span><span class="n">data</span>
    <span class="n">myVariable</span>      <span class="kt">DD</span> <span class="mi">42</span>
    <span class="n">myOtherVariable</span> <span class="kt">DD</span> <span class="mh">0xBEEFBEEF</span>
    <span class="n">myBeefVariable</span>  <span class="kt">DD</span> <span class="mh">0x0BADBEEF</span>
 
</code></pre></div></div>

<p>Note due to hardware restrictions, direct memory-to-memory moves are not allowed. You have to store in a register first.</p>

<p>Similarly to before, <code class="highlighter-rouge">.text</code> is a marker to indicate the things which come next are code to be executed.</p>

<p>We’ve also introduced a special label <code class="highlighter-rouge">_main</code> to tell the compiler exactly where our code begins. This is required for running this on Windows, so Windows knows how to place our bits into RAM such that they will be executed.</p>

<p>Finally, the final <code class="highlighter-rouge">retn</code> instruction is how we say our code is done. It <em>returns</em> from the main function, which returns control to the operating system to clean up as needed and do something else. If you had no operating system, you might use <code class="highlighter-rouge">hlt</code> to actually halt the processor.</p>

<p>After all this, we can assemble, link, and run the code. Using a special tool (called a debugger), we inspect the results of the registers after our code is run and see the result:</p>

<p><img src="/assets/sample_mov_asm_run_result.png" alt="Code run result" /></p>

<p>As expected, our variables and registers got updated as promised in the comments! Our new unused variable friend <code class="highlighter-rouge">myBeefVariable</code> remains as it was when we started.</p>

<h4 id="math-and-logic">Math And Logic</h4>

<p>Moving values from here to there is all well and good, but we generally also want to do math on those values.</p>

<p><img src="/assets/controlUnitMath.png" alt="Control Unit Math" /></p>

<p>Fortunately, x86 provides a wide array of math operations for us to choose from. These include, but are not limited to:</p>

<ol>
  <li><code class="highlighter-rouge">add</code> and <code class="highlighter-rouge">sub</code> - Adds or Subtracts two values</li>
  <li><code class="highlighter-rouge">imul</code> and <code class="highlighter-rouge">idiv</code> - performs integer multiplication or division on two values</li>
  <li><code class="highlighter-rouge">and</code>, <code class="highlighter-rouge">or</code>, <code class="highlighter-rouge">not</code> - performs bit-wise boolean operations on one or two values.</li>
</ol>

<p>There are many more, some involving floating point numbers. While super useful they’re beyond the scope of this discussion.</p>

<p>Usually these take two or three operands - <code class="highlighter-rouge">&lt;operation&gt; &lt;input1&gt; &lt;input2&gt;</code>. Here, <em>operation</em> is performed on <em>input1</em> and <em>input2</em>, and the result gets stored back into <em>input1</em>. This is convenient if you are keeping a running total of something, and just requires an extra <code class="highlighter-rouge">mov</code> if your destination is different than the inputs.</p>

<p>For example, to add <code class="highlighter-rouge">EAX</code> and <code class="highlighter-rouge">EBX</code> together, and store the result into <code class="highlighter-rouge">ECX</code>, you would provide the assembly code:</p>

<div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">mov</span> <span class="n">ECX</span><span class="p">,</span> <span class="n">EAX</span>  <span class="c">; Copy first operand into the output location</span>
<span class="k">add</span> <span class="n">ECX</span><span class="p">,</span> <span class="n">EBX</span>  <span class="c">; Add the value in ECX (same as EAX) to EBX, storing back into ECX</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">sub</code> works very similarly. As a worked example:</p>

<div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">; ----------------------------------------------------------------------------</span>
<span class="c">; sample.asm</span>
<span class="c">; ----------------------------------------------------------------------------</span>

    <span class="kr">global</span>  <span class="n">_main</span>

<span class="c">; ----------------------------------------------------------------------------</span>
<span class="c">; Code Starts Here</span>

<span class="kr">section</span> <span class="p">.</span><span class="n">text</span>

<span class="n">_main</span><span class="o">:</span>
    <span class="k">mov</span> <span class="n">EAX</span><span class="p">,</span> <span class="mi">10</span>   <span class="c">; Init our inputs with some values</span>
    <span class="k">mov</span> <span class="n">EBX</span><span class="p">,</span> <span class="mi">15</span>

    <span class="k">mov</span> <span class="n">ECX</span><span class="p">,</span> <span class="n">EAX</span>  <span class="c">; Copy first operand into the output location</span>
    <span class="k">add</span> <span class="n">ECX</span><span class="p">,</span> <span class="n">EBX</span>  <span class="c">; Add the value in ECX (same as EAX) to EBX, storing back into ECX</span>
                  <span class="c">; ECX should be 10+15 = 25</span>

    <span class="k">mov</span> <span class="n">EDX</span><span class="p">,</span> <span class="n">EAX</span>  <span class="c">; Copy first operand into the output location</span>
    <span class="k">sub</span> <span class="n">EDX</span><span class="p">,</span> <span class="n">EBX</span>  <span class="c">; Subtract the value in EDX (same as EAX) from EBX, storing back into EDX</span>
                  <span class="c">; EDX should be 10-15 = -5</span>


    <span class="c">; We are done executing - return control to the operating system</span>
    <span class="k">retn</span> 

<span class="c">; ----------------------------------------------------------------------------</span>
<span class="c">; Global Variables</span>

<span class="kr">section</span> <span class="p">.</span><span class="n">data</span>


</code></pre></div></div>

<p>True to the comments, add and subtract operations put the results into <code class="highlighter-rouge">ECX</code> and <code class="highlighter-rouge">EDX</code>.</p>

<p><img src="/assets/sample_math_asm_run_result.png" alt="Code run result" /></p>

<p>Similarly, we can do bitwise logic operations on values. Instructions like <code class="highlighter-rouge">and</code>, <code class="highlighter-rouge">or</code>, and <code class="highlighter-rouge">not</code> do exactly what you’d expect, and follow very similar formatting to our math instruction friends. Yet another worked example of their operation:</p>

<div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">; ----------------------------------------------------------------------------</span>
<span class="c">; sample.asm</span>
<span class="c">; ----------------------------------------------------------------------------</span>

    <span class="kr">global</span>  <span class="n">_main</span>

<span class="c">; ----------------------------------------------------------------------------</span>
<span class="c">; Code Starts Here</span>

<span class="kr">section</span> <span class="p">.</span><span class="n">text</span>

<span class="n">_main</span><span class="o">:</span>
    <span class="k">mov</span> <span class="n">EAX</span><span class="p">,</span> <span class="mi">0</span><span class="n">b10101100110000111010110011000011</span>   <span class="c">; Init our inputs  </span>
    <span class="k">mov</span> <span class="n">EBX</span><span class="p">,</span> <span class="mi">0</span><span class="n">b00001111000011110000111100001111</span>   <span class="c">; Use random-ish 32-bit values</span>

    <span class="k">mov</span> <span class="n">ECX</span><span class="p">,</span> <span class="n">EAX</span>          <span class="c">; Copy first operand into the output location</span>
    <span class="k">and</span> <span class="n">ECX</span><span class="p">,</span> <span class="n">EBX</span>          <span class="c">; Perform bitwise AND on the two values</span>
    <span class="k">mov</span> <span class="p">[andResult],</span> <span class="n">ECX</span>  <span class="c">; Store into the global variable for later inspection</span>

    <span class="k">mov</span> <span class="n">ECX</span><span class="p">,</span> <span class="n">EAX</span>          <span class="c">; Copy first operand into the output location</span>
    <span class="k">or</span> <span class="n">ECX</span><span class="p">,</span> <span class="n">EBX</span>           <span class="c">; Perform bitwise OR on the two values</span>
    <span class="k">mov</span> <span class="p">[orResult],</span> <span class="n">ECX</span>   <span class="c">; Store into the global variable for later inspection</span>

    <span class="k">mov</span> <span class="n">ECX</span><span class="p">,</span> <span class="n">EAX</span>          <span class="c">; Copy first operand into the output location</span>
    <span class="k">not</span> <span class="n">ECX</span>               <span class="c">; Perform bitwise NOT on the first value</span>
    <span class="k">mov</span> <span class="p">[notResult],</span> <span class="n">ECX</span>  <span class="c">; Store into the global variable for later inspection</span>

    <span class="k">mov</span> <span class="n">ECX</span><span class="p">,</span> <span class="n">EAX</span>          <span class="c">; Copy first operand into the output location</span>
    <span class="k">xor</span> <span class="n">ECX</span><span class="p">,</span> <span class="n">EBX</span>          <span class="c">; Perform bitwise NOT on the two values</span>
    <span class="k">mov</span> <span class="p">[xorResult],</span> <span class="n">ECX</span>  <span class="c">; Store into the global variable for later inspection</span>

    <span class="c">; We are done executing - return control to the operating system</span>
    <span class="k">retn</span> 

<span class="c">; ----------------------------------------------------------------------------</span>
<span class="c">; Global Variables</span>

<span class="kr">section</span> <span class="p">.</span><span class="n">data</span>
    <span class="n">andResult</span>      <span class="kt">DD</span> <span class="mh">0x0</span>
    <span class="n">orResult</span>       <span class="kt">DD</span> <span class="mh">0x0</span>
    <span class="n">notResult</span>      <span class="kt">DD</span> <span class="mh">0x0</span>
    <span class="n">xorResult</span>      <span class="kt">DD</span> <span class="mh">0x0</span>


</code></pre></div></div>

<p>The bitwise action performs the corresponding logic operation on the two numbers, one bit at a time, never inter-mixing the bits. Despite how painful it is to look at theses 32-bit sequences, the results are what you’d expect:</p>

<p><img src="/assets/sample_logic_asm_run_result.png" alt="Code run result" /></p>

<h4 id="conditional-execution">Conditional Execution</h4>

<p>So far our code is very linear in execution - we start at the top, execute all instructions in order, and then we are done. However, to actually make decisions and be more than a glorified calculator, we need to be able to tell the processor to skip or repeat instructions. This functionality is accomplished by the paired set of operations - <em>compare</em> and <em>jump</em>.</p>

<p><code class="highlighter-rouge">cmp</code>, or <em>compare</em>, is probably the easiest to understand. It takes two inputs, and compares them! In x86, the result of the comparison is stored in a very special register that is called the <em>EFLAGS</em> register. On our diagram for processor architecture, we had a “P/N/Z” register that served the same purpose. It is just a set of bits to indicate if the previous operation resulted in overflow or underflow, a positive or negative result, a zero or non-zero result, and a number of other things.</p>

<p>Since <code class="highlighter-rouge">cmp</code> sets the <em>EFLAGS</em> register, we can call a <em>jump</em> right after it to use the result.</p>

<p><em>Jump</em> comes in many different flavors, but all do the same thing - they alter the value of the next-address to be decoded as an instruction. By interrupting the normal “add-one-to-instruction-register” behavior of the processor, it enables you (the user) to change the order of execution.</p>

<p><img src="/assets/controlUnitCompareJump.png" alt="Compare and jum processor data flow" /></p>

<p>The instruction <code class="highlighter-rouge">jmp</code> itself is called an <em>unconditional jump</em> - no matter what <em>EFLAGS</em> is set to, it will always go to the provided memory address. For example, consider the following:</p>

<div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">_countBeverage</span><span class="o">:</span>
    <span class="k">add</span> <span class="p">[numBottlesBeverageOnWall],</span> <span class="mh">0x01</span>  <span class="c">; put one additional bottle of beverage on the wall</span>
    <span class="k">jmp</span> <span class="n">_countBeverage</span>                    <span class="c">; do it again.</span>

<span class="c">; ??? ummmmm when do we end?</span>

<span class="kr">section</span> <span class="p">.</span><span class="n">data</span>
    <span class="n">numBottlesBeverageOnWall</span>      <span class="kt">DD</span> <span class="mh">0x0</span> <span class="c">; Zero beverage to start.</span>
</code></pre></div></div>

<p>Like that annoying singing brother in the car ride, this code just keeps counting the number of bottles of beverage on the wall. Maybe this is what you wanted to do - doom your machine to an eternity of counting. But, let’s say we want to do something a bit more meaningful….</p>

<p>The other flavors of <em>jump</em> use the value in <em>EFLAGS</em> to <em>conditionally</em> go to the provided memory address. If the condition is not met, the usual “add-one” behavior is kept. The most common flavors are:</p>

<ol>
  <li><code class="highlighter-rouge">je</code> - Jump if Equal</li>
  <li><code class="highlighter-rouge">jne</code> - Jump if not Equal</li>
  <li><code class="highlighter-rouge">jl</code> - Jump if less than</li>
  <li><code class="highlighter-rouge">jle</code> - Jump if less than or equal to</li>
  <li><code class="highlighter-rouge">jg</code> - Jump if greater than</li>
  <li><code class="highlighter-rouge">jge</code> - Jump if greater than or equal to</li>
</ol>

<p>Obviously there’s some redundancy here, but it does let your assembly code be more intuitive to look at.</p>

<p>To show how to use these, let’s do a bit of a contrived, but still useful, example. We’ll load numbers into <code class="highlighter-rouge">EAX</code> and <code class="highlighter-rouge">EBX</code> and compare them. Based on the outcome of the result, we’ll set <code class="highlighter-rouge">ECX</code> - using (very convinenetly) <code class="highlighter-rouge">0x0A</code> for “<code class="highlighter-rouge">EAX</code> bigger”, <code class="highlighter-rouge">0x0B</code> for “<code class="highlighter-rouge">EBX</code> bigger”, and <code class="highlighter-rouge">0xAB</code> for “<code class="highlighter-rouge">EAX</code> equals <code class="highlighter-rouge">EBX</code>”.</p>

<div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">; ----------------------------------------------------------------------------</span>
<span class="c">; sample.asm</span>
<span class="c">; ----------------------------------------------------------------------------</span>

    <span class="kr">global</span>  <span class="n">_main</span>

<span class="c">; ----------------------------------------------------------------------------</span>
<span class="c">; Code Starts Here</span>

<span class="kr">section</span> <span class="p">.</span><span class="n">text</span>

<span class="n">_main</span><span class="o">:</span>
    <span class="k">mov</span> <span class="n">EAX</span><span class="p">,</span> <span class="mh">0x25</span>  <span class="c">; Init some values for comparison</span>
    <span class="k">mov</span> <span class="n">EBX</span><span class="p">,</span> <span class="mh">0x8F</span>   

    <span class="k">cmp</span> <span class="n">EAX</span><span class="p">,</span> <span class="n">EBX</span>   <span class="c">; Perform the comparison operation of EAX against EBX</span>
    <span class="k">jg</span>  <span class="n">_a_big</span>     <span class="c">; if EAX was greater, go to section _a_big</span>
    <span class="k">je</span>  <span class="n">_same</span>      <span class="c">; Otherwise, if equal, go to section _same</span>
    <span class="k">jmp</span> <span class="n">_b_big</span>     <span class="c">; Otherwise, EBX must have been bigger. </span>

<span class="n">_a_big</span><span class="o">:</span>
    <span class="k">mov</span> <span class="n">ECX</span><span class="p">,</span> <span class="mh">0x0A</span>  <span class="c">; since A was greater, put "A" into ECX</span>
    <span class="k">jmp</span> <span class="n">_done</span>

<span class="n">_b_big</span><span class="o">:</span>
    <span class="k">mov</span> <span class="n">ECX</span><span class="p">,</span> <span class="mh">0x0B</span>  <span class="c">; since B was greater, put "B" into ECX</span>
    <span class="k">jmp</span> <span class="n">_done</span>

<span class="n">_same</span><span class="o">:</span>
    <span class="k">mov</span> <span class="n">ECX</span><span class="p">,</span> <span class="mh">0xAB</span>  <span class="c">; since they were equal, put "AB" into ECX</span>
    <span class="k">jmp</span> <span class="n">_done</span>

<span class="n">_done</span><span class="o">:</span>
    <span class="c">; We are done executing - return control to the operating system</span>
    <span class="k">retn</span> 

</code></pre></div></div>

<p>Running this produces the expected output - since <script type="math/tex">5 > 2</script>, we expect <code class="highlighter-rouge">0x0A</code> in <code class="highlighter-rouge">ECX</code>, and that’s what we get:</p>

<p><img src="/assets/sample_jmp_asm_run_result.png" alt="Code run result" /></p>

<p>Also as you’d expect - if you tweak the initial values of <code class="highlighter-rouge">EAX</code> and <code class="highlighter-rouge">EBX</code>, you get different results in <code class="highlighter-rouge">ECX</code>:</p>

<p><img src="/assets/sample_jmp_asm_run_result_b_greater.png" alt="Code run result" /></p>

<p><img src="/assets/sample_jmp_asm_run_result_eq.png" alt="Code run result" /></p>

<p>A couple things of interest in this example: Note that <code class="highlighter-rouge">jmp</code> or its flavors do <em>not</em> set <em>EFLAGS</em>, so you can do a “chain” of jump instructions after one cmp instruction as above. Based off of just that one comparison, we branch off to the most-appropriate of the three subsections for manipulating <code class="highlighter-rouge">ECX</code>.</p>

<p>Also note that at the end of each small “chunk” where <code class="highlighter-rouge">ECX</code> is set, we have an unconditional <code class="highlighter-rouge">jmp</code> down to <code class="highlighter-rouge">_done</code>. Remember that without <code class="highlighter-rouge">jmp</code> calls, assembly instructions happen one after another. The assembler doesn’t know (or care) that we divided our code up with different labels like <code class="highlighter-rouge">_a_big</code> or <code class="highlighter-rouge">_b_big</code> - it just goes through instructions one after another. Without unconditional <code class="highlighter-rouge">jmp _done</code> instructions, we’d potentailyl be setting <code class="highlighter-rouge">ECX</code> multiple times, which would be incorrect.</p>

<p>However, the astute reader may be saying “Hey, one of those isn’t actually needed!” and you’re 100% right. In <code class="highlighter-rouge">_same</code>, the last <code class="highlighter-rouge">jmp _done</code> instruction is totally unnecessary from a functionality point of view.</p>

<p>This chunk of code:</p>
<div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">_same</span><span class="o">:</span>
    <span class="k">mov</span> <span class="n">ECX</span><span class="p">,</span> <span class="mh">0xAB</span>
    <span class="k">jmp</span> <span class="n">_done</span>
<span class="n">_done</span><span class="o">:</span>
    <span class="k">retn</span> 
</code></pre></div></div>

<p>Is functionally the exact same thing as:</p>
<div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">_same</span><span class="o">:</span>
    <span class="k">mov</span> <span class="n">ECX</span><span class="p">,</span> <span class="mh">0xAB</span>
<span class="n">_done</span><span class="o">:</span>
    <span class="k">retn</span> 
</code></pre></div></div>

<p>Because jumping to the next instruction is, well, exactly what the processor does by default.</p>

<p><strong>HOWEVER</strong>. A key component of “good” code usually is <em>consistency</em>. If you have three chunks of code that are <em>supposed</em> to do similar things, you should make them <em>look</em> very similar. Even if it works just fine, removing that <code class="highlighter-rouge">jmp _done</code> line forces the next person looking at your code to stop and think “Wait, why is this one different? Is that OK? Is this actually a bug?” and then a little while later come to the same conclusion as the original author did that, no, this still works fine. But, that was just some time that was wasted. Obviously, in a small case like this, it’s pretty easy to see and prove the equivalency. But, as you write more and more (and bigger and bigger) code, making a similar determination is not nearly as trivial. Best practice is to keep similar things as similar as possible.</p>

<p>Finally. It should be noted that lots of other instructions set the <em>EFLAGS</em> register - most math and logic operations, actually. Always check the manual. However, you can use this to skip the <code class="highlighter-rouge">cmp</code> instruction sometimes. Doing so will produce smaller and faster code, though sometimes at the loss of readability…. sometimes. Buyer beware.</p>

<h2 id="what-we-skipped">What We Skipped</h2>

<p>Ok, so this should be enough for now - we’ll be able to move on to explain the basics of how C code turns into bits. Of course, there is … a lot … more to x86 than what we’ve discussed here. The biggest thing we’ve left out is how you create chunks of code that can be called from anywhere, and return back where they came from when done (<em>functions</em>, for the folks who know about them already). Suffice to say, x86 has specific built in hardware support for making this happen, and we’ll probably hit it in a later blog post. No matter, it won’t be critical for the immediate discussion.</p>

<p>Similarly, there’s a whole discussion to be had as to how an x86 processor allows certain code to be “privileged” or “unprivileged”, and keeps various chunks of code isolated from each other. We’ve also completely ignored how and why the code we’re writing shows up in “.exe” files, and how said “.exe” file happens to end up with its contents on the processor. These are all inter-related topics, which hopefully we’ll touch on when we discuss how operating systems work. Again suffice to say, it won’t be required to go through now, but keep in mind that the onion still has more layers</p>

<h2 id="next-steps---where-are-we-going">Next Steps - Where are we going?</h2>

<p>With the end of this post, hopefully we’ve presented a decent introduction to the bare-bones components of x86, a real assembly language that works on real processors. We’ll use this knowledge to help deconstruct how our high level language (C code) gets converted to 1’s and 0’s on a processor, with x86 assembly as the intermediate description of the bits. <a href="/blog_posts/2019/08/17/c_to_assembly.html">Check out the last chapter here!</a></p>

<div class="footnotes">
  <ol>
    <li id="fn:1">
      <p>When I say workhorse, I really do mean it works hard, and can do a lot! Turns out, <a href="https://youtu.be/R7EEoWg6Ekk?t=39"><code class="highlighter-rouge">mov</code> by itself is <em>Turing Complete</em></a>. That’s right, you could build a computer that only know how to do <code class="highlighter-rouge">mov</code>, or limit yourself to only using <code class="highlighter-rouge">mov</code>, and still be able to <em>compute anything you want to</em>. And even more so, <a href="https://github.com/xoreaxeaxeax/movfuscator"><em>someone did it</em></a>. Seriously, this is one of my favorite exercises in all of computer science, just for its simultaneous absurdity and technical prowess. The video is long, but actually worthwhile, and totally approachable to someone who has kept pace with this blog thus far! <a href="#fnref:1" class="reversefootnote">&#8617;</a></p>
    </li>
  </ol>
</div>

  </div><a class="u-url" href="/blog_posts/2019/08/10/x86_intro.html" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">Tricking Rocks to Think</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">Tricking Rocks to Think</li><li><a class="u-email" href="mailto:webmaster@trickingrockstothink.com">webmaster@trickingrockstothink.com</a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/gerth2"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">gerth2</span></a></li><li><a href="https://www.linkedin.com/in/christopher-gerth-7b8b52126"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#linkedin"></use></svg> <span class="username">christopher-gerth-7b8b52126</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>Thoughts on software development, leadership, and sundry other topics in the context of the FIRST robotics competition.</p>
      </div>
    </div>

  </div>

</footer>
<!-- Global site tag (gtag.js) - Google Analytics -->
<!-- <script async src="https://www.googletagmanager.com/gtag/js?id=UA-140459603-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-140459603-1');
</script> -->


  </body>

</html>
