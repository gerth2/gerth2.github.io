<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.8.5">Jekyll</generator><link href="/feed.xml" rel="self" type="application/atom+xml" /><link href="/" rel="alternate" type="text/html" /><updated>2019-08-10T13:55:34-05:00</updated><id>/feed.xml</id><title type="html">Tricking Rocks to Think</title><subtitle>Thoughts on software development, leadership, and sundry other topics in the context of the FIRST robotics competition.</subtitle><entry><title type="html">x86 Assembly Introduction</title><link href="/blog_posts/2019/08/10/x86_intro.html" rel="alternate" type="text/html" title="x86 Assembly Introduction" /><published>2019-08-10T09:30:40-05:00</published><updated>2019-08-10T09:30:40-05:00</updated><id>/blog_posts/2019/08/10/x86_intro</id><content type="html" xml:base="/blog_posts/2019/08/10/x86_intro.html">&lt;p&gt;&lt;em&gt;“It is well-known that the x86 instruction set is baroque, overcomplicated, and redundantly redundant.” - &lt;a href=&quot;https://github.com/stedolan&quot;&gt;Stephen Dolan&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&quot;introduction&quot;&gt;Introduction&lt;/h2&gt;

&lt;p&gt;In our grand arc of introductory topics, this sadly is nearing the end.&lt;/p&gt;

&lt;p&gt;We now most of the basic required components to analyze how a high-level C code program can get translated into 1’s and 0’s on a processor. One last piece of the puzzle - we’ll introduce a particular assembly language - x86 - and then show how C code constructs are implemented using the assembly language.&lt;/p&gt;

&lt;h2 id=&quot;x86&quot;&gt;x86&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;x86&lt;/em&gt; (pronounced “ecks - eighty - six”) is the name for one of the most ubiquitous processor architectures in the world today. x86 is very old, dating back to some of the initial processors that Intel manufactured. Intel has been very rigirous about keeping it backward compatible, so the full specification carries most of the legacy functionality of processors manufactured 20 to 30 years ago. This makes the full specification around 2900 pages long - not exactly light reading.&lt;/p&gt;

&lt;p&gt;When learning about x86, it’s better to start not with the actual documentation, but one of &lt;a href=&quot;https://www.cs.virginia.edu/~evans/cs216/guides/x86.html&quot;&gt;the many helpful guides&lt;/a&gt; out there. &lt;a href=&quot;https://en.wikibooks.org/wiki/X86_Assembly/X86_Architecture&quot;&gt;Here is another good one.&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;the-basics&quot;&gt;The Basics&lt;/h3&gt;

&lt;p&gt;In order to introduce how your C code gets executed on a processor, we’re going to start by a basic overview of how programming in x86 assembly works.&lt;/p&gt;

&lt;p&gt;As a basic review, recall that when we write assembly code, there is a &lt;em&gt;one to one&lt;/em&gt; mapping from assembly instructions to bits that go into and out of the processor. Whenever we describe some particular &lt;em&gt;assembly instruction&lt;/em&gt; in this post, just remember that you can go straight from that to bits.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Which bits&lt;/em&gt; is described within the &lt;a href=&quot;https://www.intel.com/content/dam/www/public/us/en/documents/manuals/64-ia-32-architectures-software-developer-instruction-set-reference-manual-325383.pdf&quot;&gt;x86 software developer’s reference manual&lt;/a&gt;. This behemoth of documentation describes, in great detail, the operation of every assembly instruction, and how to encode it into bits. Diagrams like this one explain the mapping:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/intel_inst_format.png&quot; alt=&quot;Intel instruction set bit format&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Which, as you are probably guessing, is not the most straightforward of methodologies. It’s totally feasable to figure out though, but that figuring will be left as an exerices to the user. It’s all there in that manual though, I promise.&lt;/p&gt;

&lt;p&gt;Again though, at least for the sake of this post, keep in mind that given an assembly instruction, you can get bits which go into a processor. All such that we can define what the starting layout of 1’s and 0’s in our RAM looks like:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/controlUnitMemoryLayout.png&quot; alt=&quot;Control Unit RAM&quot; /&gt;&lt;/p&gt;

&lt;p&gt;When writing assembly code, what you are really doing is defining the bits that will go into memory as the &lt;em&gt;stored program&lt;/em&gt;, eventually executed by a processor. Once you have the right set of bits, you just have to load them into memory at just the right spot, then fire up the processor. It will pick the first address, and start running your program from the beginning.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;How&lt;/em&gt; these instructions are loaded into Memory will have to be a future post, as it’s beyond the scope of this discussion. For now, I promise, there &lt;em&gt;is&lt;/em&gt; a way to make it happen, and it does happen.&lt;/p&gt;

&lt;h4 id=&quot;setting-aside-memory-for-storage&quot;&gt;Setting Aside Memory for Storage&lt;/h4&gt;

&lt;p&gt;In addition to the actual instructions to run, you’ll also generally want to reserve memory locations to store values. Here’s a brief hint of where we’re going - remember variables from C syntax? Any time you have a variable, you’ll need some memory to store it. When writing x86 assembly, you can mark off a sets of bits for usage as variables:&lt;/p&gt;

&lt;div class=&quot;language-nasm highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kr&quot;&gt;section&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;myVariable&lt;/span&gt;  &lt;span class=&quot;kt&quot;&gt;DB&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;42&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;myOtherVariable&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;DW&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;25&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The &lt;code class=&quot;highlighter-rouge&quot;&gt;.data&lt;/code&gt; directive tells the assembler that the things which follow are memory locations for variables, not code. The name of the variable comes first, followed by some string like &lt;code class=&quot;highlighter-rouge&quot;&gt;DB&lt;/code&gt; or &lt;code class=&quot;highlighter-rouge&quot;&gt;DW&lt;/code&gt; to indicate &lt;em&gt;how many&lt;/em&gt; bytes the variable occupies. &lt;code class=&quot;highlighter-rouge&quot;&gt;DB&lt;/code&gt; is one byte, &lt;code class=&quot;highlighter-rouge&quot;&gt;DW&lt;/code&gt; is two, &lt;code class=&quot;highlighter-rouge&quot;&gt;DD&lt;/code&gt; is four… others exist. The final thing can be optional, and dictates what the memory is to be set to prior to any code running. In this case, &lt;code class=&quot;highlighter-rouge&quot;&gt;myVariable&lt;/code&gt; gets set to &lt;a href=&quot;https://en.wikipedia.org/wiki/Phrases_from_The_Hitchhiker%27s_Guide_to_the_Galaxy#Answer_to_the_Ultimate_Question_of_Life,_the_Universe,_and_Everything_(42)&quot;&gt;The Answer to the Ultimate Question of Life, the Universe, and Everything&lt;/a&gt;, while &lt;code class=&quot;highlighter-rouge&quot;&gt;myOtherVariable&lt;/code&gt; gets set to 25.&lt;/p&gt;

&lt;p&gt;It’s worthwhile to note that when working with these labeled memory locations, the name (eg, &lt;code class=&quot;highlighter-rouge&quot;&gt;myVariable&lt;/code&gt;) refers to the actual memory &lt;em&gt;address&lt;/em&gt;, while putting it in brackets (eg, &lt;code class=&quot;highlighter-rouge&quot;&gt;[myVariable]&lt;/code&gt;) refers to the &lt;em&gt;value at that address&lt;/em&gt;. When working with instructions, sometimes the assembly instruction needs a memory address, and other times it needs a value. Use each form as needed.&lt;/p&gt;

&lt;p&gt;As in all programming languages worth their salt, it is also possible to write comments in your assembly code.&lt;/p&gt;

&lt;div class=&quot;language-nasm highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;;---------------------------------------------------&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;; Herp Derp this is where the global variables go!&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;; Aren't comments the best?&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;;---------------------------------------------------&lt;/span&gt;
&lt;span class=&quot;kr&quot;&gt;section&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;myVariable&lt;/span&gt;  &lt;span class=&quot;kt&quot;&gt;DB&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;42&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;myOtherVariable&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;DW&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;25&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;registers&quot;&gt;Registers&lt;/h4&gt;

&lt;p&gt;We’ll now attempt to describe the General Purpose registers of interest to us in x86 processor architecture.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/controlUnitRegisters.png&quot; alt=&quot;Control Unit GPRs&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Accessing memory addresses can be slow, so for rapid access of heavily-manipulated values, it’s common place to use a &lt;em&gt;general purpose&lt;/em&gt; register to store the quantity. Physically located close to the center of the processor and implemented with high-speed circuitry, these registers are limited in quantity but abundant in speed and capiability. Additionally, some assembly instructions can only work with certain registers, so it’s required to populate the register first before running the restricted assembly instruction.&lt;/p&gt;

&lt;p&gt;There are a lof these on the x86 architecture, but there’s just a handful we’ll focus on for now. Their names are:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;EAX&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;EBX&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ECX&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;EDX&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;These four in particular can be used to store pretty much whatever values you want. Other registers have more restrictions, but these are the most general-purpose of all the general-purpose registers.&lt;/p&gt;

&lt;h4 id=&quot;memory-and-register-transfer&quot;&gt;Memory and Register Transfer&lt;/h4&gt;

&lt;p&gt;To do anything useful, we’ll first want to know how to assign and move data values around in the processor.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/controlUnitMemoryOps.png&quot; alt=&quot;Control Unit Memory Operations&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;mov&lt;/code&gt; is the first assembly instruction we will cover. &lt;code class=&quot;highlighter-rouge&quot;&gt;mov&lt;/code&gt; stands for &lt;em&gt;move&lt;/em&gt;. It’s the true workhorse of the x86 assembly language. &lt;sup id=&quot;fnref:1&quot;&gt;&lt;a href=&quot;#fn:1&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt; It’s primary job - move values from one place to another. Fundamentally the syntax is:&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;mov &amp;lt;dst&amp;gt; &amp;lt;src&amp;gt;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;It can move constant values into registers or memory, move between registers, or move between registers and memory:&lt;/p&gt;
&lt;div class=&quot;language-nasm highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;; ----------------------------------------------------------------------------&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;; sample.asm&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;; ----------------------------------------------------------------------------&lt;/span&gt;

    &lt;span class=&quot;kr&quot;&gt;global&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;_main&lt;/span&gt;

&lt;span class=&quot;c&quot;&gt;; ----------------------------------------------------------------------------&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;; Code Starts Here&lt;/span&gt;

&lt;span class=&quot;kr&quot;&gt;section&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;text&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;_main&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;mov&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;EAX&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[myVariable]&lt;/span&gt;            &lt;span class=&quot;c&quot;&gt;; Move the value at myVariable into EAX &lt;/span&gt;
                                     &lt;span class=&quot;c&quot;&gt;; EAX now contains 42&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;mov&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;EBX&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1234&lt;/span&gt;                    &lt;span class=&quot;c&quot;&gt;; Move the constant value 1234 into EBX&lt;/span&gt;
                                     &lt;span class=&quot;c&quot;&gt;; EBX now contains 1234&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;mov&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;EDX&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;EAX&lt;/span&gt;                     &lt;span class=&quot;c&quot;&gt;; Load EDX with the present value of EAX&lt;/span&gt;
                                     &lt;span class=&quot;c&quot;&gt;; EDX is now also 42&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;mov&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dword&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[myOtherVariable],&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;25&lt;/span&gt;  &lt;span class=&quot;c&quot;&gt;; Load the constant value 25 into &lt;/span&gt;
                                     &lt;span class=&quot;c&quot;&gt;;   all 32 of the bits of myOtherVariable&lt;/span&gt;
                                     &lt;span class=&quot;c&quot;&gt;; The memory allocated at label &lt;/span&gt;
                                     &lt;span class=&quot;c&quot;&gt;;   &quot;myOtherVariable&quot; now has value 25&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;mov&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ECX&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[myOtherVariable]&lt;/span&gt;       &lt;span class=&quot;c&quot;&gt;; Load ECX with the value from memory &lt;/span&gt;
                                     &lt;span class=&quot;c&quot;&gt;;   labeled &quot;myOtherVariable&quot;&lt;/span&gt;
                                     &lt;span class=&quot;c&quot;&gt;; ECX is now also 25&lt;/span&gt;

    &lt;span class=&quot;c&quot;&gt;; We are done executing - return control to the operating system&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;retn&lt;/span&gt; 

&lt;span class=&quot;c&quot;&gt;; ----------------------------------------------------------------------------&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;; Global Variables&lt;/span&gt;

&lt;span class=&quot;kr&quot;&gt;section&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;myVariable&lt;/span&gt;      &lt;span class=&quot;kt&quot;&gt;DD&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;42&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;myOtherVariable&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;DD&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0xBEEFBEEF&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;myBeefVariable&lt;/span&gt;  &lt;span class=&quot;kt&quot;&gt;DD&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x0BADBEEF&lt;/span&gt;
 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Note due to hardware restrictions, direct memory-to-memory moves are not allowed. You have to store in a register first.&lt;/p&gt;

&lt;p&gt;Similarly to before, &lt;code class=&quot;highlighter-rouge&quot;&gt;.text&lt;/code&gt; is a marker to indicate the things which come next are code to be executed.&lt;/p&gt;

&lt;p&gt;We’ve also introduced a special label &lt;code class=&quot;highlighter-rouge&quot;&gt;_main&lt;/code&gt; to tell the compiler exactly where our code begins. This is required for running this on Windows, so Windows knows how to place our bits into RAM such that they will be executed.&lt;/p&gt;

&lt;p&gt;Finally, the final &lt;code class=&quot;highlighter-rouge&quot;&gt;retn&lt;/code&gt; instruction is how we say our code is done. It &lt;em&gt;returns&lt;/em&gt; from the main function, which returns control to the operating system to clean up as needed and do something else. If you had no operating system, you might use &lt;code class=&quot;highlighter-rouge&quot;&gt;hlt&lt;/code&gt; to actually halt the processor.&lt;/p&gt;

&lt;p&gt;After all this, we can assemble, link, and run the code. Using a special tool (called a debugger), we inspect the results of the registers after our code is run and see the result:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/sample_mov_asm_run_result.png&quot; alt=&quot;Code run result&quot; /&gt;&lt;/p&gt;

&lt;p&gt;As expected, our variables and registers got updated as promised in the comments! Our new unused variable friend &lt;code class=&quot;highlighter-rouge&quot;&gt;myBeefVariable&lt;/code&gt; remains as it was when we started.&lt;/p&gt;

&lt;h4 id=&quot;math-and-logic&quot;&gt;Math And Logic&lt;/h4&gt;

&lt;p&gt;Moving values from here to there is all well and good, but we generally also want to do math on those values.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/controlUnitMath.png&quot; alt=&quot;Control Unit Math&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Fortunately, x86 provides a wide array of math operations for us to choose from. These include, but are not limited to:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;add&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;sub&lt;/code&gt; - Adds or Subtracts two values&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;imul&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;idiv&lt;/code&gt; - performs integer multiplication or division on two values&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;and&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;or&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;not&lt;/code&gt; - performs bit-wise boolean operations on one or two values.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;There are many more, some involving floating point numbers. While super useful they’re beyond the scope of this discussion.&lt;/p&gt;

&lt;p&gt;Usually these take two or three operands - &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;operation&amp;gt; &amp;lt;input1&amp;gt; &amp;lt;input2&amp;gt;&lt;/code&gt;. Here, &lt;em&gt;operation&lt;/em&gt; is performed on &lt;em&gt;input1&lt;/em&gt; and &lt;em&gt;input2&lt;/em&gt;, and the result gets stored back into &lt;em&gt;input1&lt;/em&gt;. This is convenient if you are keeping a running total of something, and just requires an extra &lt;code class=&quot;highlighter-rouge&quot;&gt;mov&lt;/code&gt; if your destination is different than the inputs.&lt;/p&gt;

&lt;p&gt;For example, to add &lt;code class=&quot;highlighter-rouge&quot;&gt;EAX&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;EBX&lt;/code&gt; together, and store the result into &lt;code class=&quot;highlighter-rouge&quot;&gt;ECX&lt;/code&gt;, you would provide the assembly code:&lt;/p&gt;

&lt;div class=&quot;language-nasm highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;mov&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ECX&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;EAX&lt;/span&gt;  &lt;span class=&quot;c&quot;&gt;; Copy first operand into the output location&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;add&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ECX&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;EBX&lt;/span&gt;  &lt;span class=&quot;c&quot;&gt;; Add the value in ECX (same as EAX) to EBX, storing back into ECX&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;sub&lt;/code&gt; works very similarly. As a worked example:&lt;/p&gt;

&lt;div class=&quot;language-nasm highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;; ----------------------------------------------------------------------------&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;; sample.asm&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;; ----------------------------------------------------------------------------&lt;/span&gt;

    &lt;span class=&quot;kr&quot;&gt;global&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;_main&lt;/span&gt;

&lt;span class=&quot;c&quot;&gt;; ----------------------------------------------------------------------------&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;; Code Starts Here&lt;/span&gt;

&lt;span class=&quot;kr&quot;&gt;section&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;text&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;_main&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;mov&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;EAX&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;   &lt;span class=&quot;c&quot;&gt;; Init our inputs with some values&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;mov&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;EBX&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;15&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;mov&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ECX&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;EAX&lt;/span&gt;  &lt;span class=&quot;c&quot;&gt;; Copy first operand into the output location&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;add&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ECX&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;EBX&lt;/span&gt;  &lt;span class=&quot;c&quot;&gt;; Add the value in ECX (same as EAX) to EBX, storing back into ECX&lt;/span&gt;
                  &lt;span class=&quot;c&quot;&gt;; ECX should be 10+15 = 25&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;mov&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;EDX&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;EAX&lt;/span&gt;  &lt;span class=&quot;c&quot;&gt;; Copy first operand into the output location&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;sub&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;EDX&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;EBX&lt;/span&gt;  &lt;span class=&quot;c&quot;&gt;; Subtract the value in EDX (same as EAX) from EBX, storing back into EDX&lt;/span&gt;
                  &lt;span class=&quot;c&quot;&gt;; EDX should be 10-15 = -5&lt;/span&gt;


    &lt;span class=&quot;c&quot;&gt;; We are done executing - return control to the operating system&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;retn&lt;/span&gt; 

&lt;span class=&quot;c&quot;&gt;; ----------------------------------------------------------------------------&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;; Global Variables&lt;/span&gt;

&lt;span class=&quot;kr&quot;&gt;section&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;


&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;True to the comments, add and subtract operations put the results into &lt;code class=&quot;highlighter-rouge&quot;&gt;ECX&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;EDX&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/sample_math_asm_run_result.png&quot; alt=&quot;Code run result&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Similarly, we can do bitwise logic operations on values. Instructions like &lt;code class=&quot;highlighter-rouge&quot;&gt;and&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;or&lt;/code&gt;, and &lt;code class=&quot;highlighter-rouge&quot;&gt;not&lt;/code&gt; do exactly what you’d expect, and follow very similar formatting to our math instruction friends. Yet another worked example of their operation:&lt;/p&gt;

&lt;div class=&quot;language-nasm highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;; ----------------------------------------------------------------------------&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;; sample.asm&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;; ----------------------------------------------------------------------------&lt;/span&gt;

    &lt;span class=&quot;kr&quot;&gt;global&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;_main&lt;/span&gt;

&lt;span class=&quot;c&quot;&gt;; ----------------------------------------------------------------------------&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;; Code Starts Here&lt;/span&gt;

&lt;span class=&quot;kr&quot;&gt;section&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;text&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;_main&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;mov&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;EAX&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b10101100110000111010110011000011&lt;/span&gt;   &lt;span class=&quot;c&quot;&gt;; Init our inputs  &lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;mov&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;EBX&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b00001111000011110000111100001111&lt;/span&gt;   &lt;span class=&quot;c&quot;&gt;; Use random-ish 32-bit values&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;mov&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ECX&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;EAX&lt;/span&gt;          &lt;span class=&quot;c&quot;&gt;; Copy first operand into the output location&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;and&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ECX&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;EBX&lt;/span&gt;          &lt;span class=&quot;c&quot;&gt;; Perform bitwise AND on the two values&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;mov&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[andResult],&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ECX&lt;/span&gt;  &lt;span class=&quot;c&quot;&gt;; Store into the global variable for later inspection&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;mov&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ECX&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;EAX&lt;/span&gt;          &lt;span class=&quot;c&quot;&gt;; Copy first operand into the output location&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;or&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ECX&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;EBX&lt;/span&gt;           &lt;span class=&quot;c&quot;&gt;; Perform bitwise OR on the two values&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;mov&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[orResult],&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ECX&lt;/span&gt;   &lt;span class=&quot;c&quot;&gt;; Store into the global variable for later inspection&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;mov&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ECX&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;EAX&lt;/span&gt;          &lt;span class=&quot;c&quot;&gt;; Copy first operand into the output location&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;not&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ECX&lt;/span&gt;               &lt;span class=&quot;c&quot;&gt;; Perform bitwise NOT on the first value&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;mov&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[notResult],&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ECX&lt;/span&gt;  &lt;span class=&quot;c&quot;&gt;; Store into the global variable for later inspection&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;mov&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ECX&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;EAX&lt;/span&gt;          &lt;span class=&quot;c&quot;&gt;; Copy first operand into the output location&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;xor&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ECX&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;EBX&lt;/span&gt;          &lt;span class=&quot;c&quot;&gt;; Perform bitwise NOT on the two values&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;mov&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[xorResult],&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ECX&lt;/span&gt;  &lt;span class=&quot;c&quot;&gt;; Store into the global variable for later inspection&lt;/span&gt;

    &lt;span class=&quot;c&quot;&gt;; We are done executing - return control to the operating system&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;retn&lt;/span&gt; 

&lt;span class=&quot;c&quot;&gt;; ----------------------------------------------------------------------------&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;; Global Variables&lt;/span&gt;

&lt;span class=&quot;kr&quot;&gt;section&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;andResult&lt;/span&gt;      &lt;span class=&quot;kt&quot;&gt;DD&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x0&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;orResult&lt;/span&gt;       &lt;span class=&quot;kt&quot;&gt;DD&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x0&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;notResult&lt;/span&gt;      &lt;span class=&quot;kt&quot;&gt;DD&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x0&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;xorResult&lt;/span&gt;      &lt;span class=&quot;kt&quot;&gt;DD&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x0&lt;/span&gt;


&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The bitwise action performs the corresponding logic operation on the two numbers, one bit at a time, never inter-mixing the bits. Despite how painful it is to look at theses 32-bit sequences, the results are what you’d expect:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/sample_logic_asm_run_result.png&quot; alt=&quot;Code run result&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;conditional-execution&quot;&gt;Conditional Execution&lt;/h4&gt;

&lt;p&gt;So far our code is very linear in execution - we start at the top, execute all instructions in order, and then we are done. However, to actually make decisions and be more than a glorified calculator, we need to be able to tell the processor to skip or repeat instructions. This functionality is accomplished by the paired set of operations - &lt;em&gt;compare&lt;/em&gt; and &lt;em&gt;jump&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;cmp&lt;/code&gt;, or &lt;em&gt;compare&lt;/em&gt;, is probably the easiest to understand. It takes two inputs, and compares them! In x86, the result of the comparison is stored in a very special register that is called the &lt;em&gt;EFLAGS&lt;/em&gt; register. On our diagram for processor architecture, we had a “P/N/Z” register that served the same purpose. It is just a set of bits to indicate if the previous operation resulted in overflow or underflow, a positive or negative result, a zero or non-zero result, and a number of other things.&lt;/p&gt;

&lt;p&gt;Since &lt;code class=&quot;highlighter-rouge&quot;&gt;cmp&lt;/code&gt; sets the &lt;em&gt;EFLAGS&lt;/em&gt; register, we can call a &lt;em&gt;jump&lt;/em&gt; right after it to use the result.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Jump&lt;/em&gt; comes in many different flavors, but all do the same thing - they alter the value of the next-address to be decoded as an instruction. By interrupting the normal “add-one-to-instruction-register” behavior of the processor, it enables you (the user) to change the order of execution.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/controlUnitCompareJump.png&quot; alt=&quot;Compare and jum processor data flow&quot; /&gt;&lt;/p&gt;

&lt;p&gt;The instruction &lt;code class=&quot;highlighter-rouge&quot;&gt;jmp&lt;/code&gt; itself is called an &lt;em&gt;unconditional jump&lt;/em&gt; - no matter what &lt;em&gt;EFLAGS&lt;/em&gt; is set to, it will always go to the provided memory address. For example, consider the following:&lt;/p&gt;

&lt;div class=&quot;language-nasm highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;_countBeverage&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;add&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[numBottlesBeverageOnWall],&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x01&lt;/span&gt;  &lt;span class=&quot;c&quot;&gt;; put one additional bottle of beverage on the wall&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;jmp&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_countBeverage&lt;/span&gt;                    &lt;span class=&quot;c&quot;&gt;; do it again.&lt;/span&gt;

&lt;span class=&quot;c&quot;&gt;; ??? ummmmm when do we end?&lt;/span&gt;

&lt;span class=&quot;kr&quot;&gt;section&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;numBottlesBeverageOnWall&lt;/span&gt;      &lt;span class=&quot;kt&quot;&gt;DD&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x0&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;; Zero beverage to start.&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Like that annoying singing brother in the car ride, this code just keeps counting the number of bottles of beverage on the wall. Maybe this is what you wanted to do - doom your machine to an eternity of counting. But, let’s say we want to do something a bit more meaningful….&lt;/p&gt;

&lt;p&gt;The other flavors of &lt;em&gt;jump&lt;/em&gt; use the value in &lt;em&gt;EFLAGS&lt;/em&gt; to &lt;em&gt;conditionally&lt;/em&gt; go to the provided memory address. If the condition is not met, the usual “add-one” behavior is kept. The most common flavors are:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;je&lt;/code&gt; - Jump if Equal&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;jne&lt;/code&gt; - Jump if not Equal&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;jl&lt;/code&gt; - Jump if less than&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;jle&lt;/code&gt; - Jump if less than or equal to&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;jg&lt;/code&gt; - Jump if greater than&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;jge&lt;/code&gt; - Jump if greater than or equal to&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Obviously there’s some redundancy here, but it does let your assembly code be more intuitive to look at.&lt;/p&gt;

&lt;p&gt;To show how to use these, let’s do a bit of a contrived, but still useful, example. We’ll load numbers into &lt;code class=&quot;highlighter-rouge&quot;&gt;EAX&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;EBX&lt;/code&gt; and compare them. Based on the outcome of the result, we’ll set &lt;code class=&quot;highlighter-rouge&quot;&gt;ECX&lt;/code&gt; - using (very convinenetly) &lt;code class=&quot;highlighter-rouge&quot;&gt;0x0A&lt;/code&gt; for “&lt;code class=&quot;highlighter-rouge&quot;&gt;EAX&lt;/code&gt; bigger”, &lt;code class=&quot;highlighter-rouge&quot;&gt;0x0B&lt;/code&gt; for “&lt;code class=&quot;highlighter-rouge&quot;&gt;EBX&lt;/code&gt; bigger”, and &lt;code class=&quot;highlighter-rouge&quot;&gt;0xAB&lt;/code&gt; for “&lt;code class=&quot;highlighter-rouge&quot;&gt;EAX&lt;/code&gt; equals &lt;code class=&quot;highlighter-rouge&quot;&gt;EBX&lt;/code&gt;”.&lt;/p&gt;

&lt;div class=&quot;language-nasm highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;; ----------------------------------------------------------------------------&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;; sample.asm&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;; ----------------------------------------------------------------------------&lt;/span&gt;

    &lt;span class=&quot;kr&quot;&gt;global&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;_main&lt;/span&gt;

&lt;span class=&quot;c&quot;&gt;; ----------------------------------------------------------------------------&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;; Code Starts Here&lt;/span&gt;

&lt;span class=&quot;kr&quot;&gt;section&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;text&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;_main&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;mov&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;EAX&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x25&lt;/span&gt;  &lt;span class=&quot;c&quot;&gt;; Init some values for comparison&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;mov&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;EBX&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x8F&lt;/span&gt;   

    &lt;span class=&quot;k&quot;&gt;cmp&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;EAX&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;EBX&lt;/span&gt;   &lt;span class=&quot;c&quot;&gt;; Perform the comparison operation of EAX against EBX&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;jg&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;_a_big&lt;/span&gt;     &lt;span class=&quot;c&quot;&gt;; if EAX was greater, go to section _a_big&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;je&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;_same&lt;/span&gt;      &lt;span class=&quot;c&quot;&gt;; Otherwise, if equal, go to section _same&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;jmp&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_b_big&lt;/span&gt;     &lt;span class=&quot;c&quot;&gt;; Otherwise, EBX must have been bigger. &lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;_a_big&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;mov&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ECX&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x0A&lt;/span&gt;  &lt;span class=&quot;c&quot;&gt;; since A was greater, put &quot;A&quot; into ECX&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;jmp&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_done&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;_b_big&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;mov&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ECX&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x0B&lt;/span&gt;  &lt;span class=&quot;c&quot;&gt;; since B was greater, put &quot;B&quot; into ECX&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;jmp&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_done&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;_same&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;mov&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ECX&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0xAB&lt;/span&gt;  &lt;span class=&quot;c&quot;&gt;; since they were equal, put &quot;AB&quot; into ECX&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;jmp&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_done&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;_done&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;; We are done executing - return control to the operating system&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;retn&lt;/span&gt; 

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Running this produces the expected output - since &lt;script type=&quot;math/tex&quot;&gt;5 &gt; 2&lt;/script&gt;, we expect &lt;code class=&quot;highlighter-rouge&quot;&gt;0x0A&lt;/code&gt; in &lt;code class=&quot;highlighter-rouge&quot;&gt;ECX&lt;/code&gt;, and that’s what we get:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/sample_jmp_asm_run_result.png&quot; alt=&quot;Code run result&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Also as you’d expect - if you tweak the initial values of &lt;code class=&quot;highlighter-rouge&quot;&gt;EAX&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;EBX&lt;/code&gt;, you get different results in &lt;code class=&quot;highlighter-rouge&quot;&gt;ECX&lt;/code&gt;:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/sample_jmp_asm_run_result_b_greater.png&quot; alt=&quot;Code run result&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/sample_jmp_asm_run_result_eq.png&quot; alt=&quot;Code run result&quot; /&gt;&lt;/p&gt;

&lt;p&gt;A couple things of interest in this example: Note that &lt;code class=&quot;highlighter-rouge&quot;&gt;jmp&lt;/code&gt; or its flavors do &lt;em&gt;not&lt;/em&gt; set &lt;em&gt;EFLAGS&lt;/em&gt;, so you can do a “chain” of jump instructions after one cmp instruction as above. Based off of just that one comparison, we branch off to the most-appropriate of the three subsections for manipulating &lt;code class=&quot;highlighter-rouge&quot;&gt;ECX&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Also note that at the end of each small “chunk” where &lt;code class=&quot;highlighter-rouge&quot;&gt;ECX&lt;/code&gt; is set, we have an unconditional &lt;code class=&quot;highlighter-rouge&quot;&gt;jmp&lt;/code&gt; down to &lt;code class=&quot;highlighter-rouge&quot;&gt;_done&lt;/code&gt;. Remember that without &lt;code class=&quot;highlighter-rouge&quot;&gt;jmp&lt;/code&gt; calls, assembly instructions happen one after another. The assembler doesn’t know (or care) that we divided our code up with different labels like &lt;code class=&quot;highlighter-rouge&quot;&gt;_a_big&lt;/code&gt; or &lt;code class=&quot;highlighter-rouge&quot;&gt;_b_big&lt;/code&gt; - it just goes through instructions one after another. Without unconditional &lt;code class=&quot;highlighter-rouge&quot;&gt;jmp _done&lt;/code&gt; instructions, we’d potentailyl be setting &lt;code class=&quot;highlighter-rouge&quot;&gt;ECX&lt;/code&gt; multiple times, which would be incorrect.&lt;/p&gt;

&lt;p&gt;However, the astute reader may be saying “Hey, one of those isn’t actually needed!” and you’re 100% right. In &lt;code class=&quot;highlighter-rouge&quot;&gt;_same&lt;/code&gt;, the last &lt;code class=&quot;highlighter-rouge&quot;&gt;jmp _done&lt;/code&gt; instruction is totally unnecessary from a functionality point of view.&lt;/p&gt;

&lt;p&gt;This chunk of code:&lt;/p&gt;
&lt;div class=&quot;language-nasm highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;_same&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;mov&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ECX&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0xAB&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;jmp&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_done&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;_done&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;retn&lt;/span&gt; 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Is functionally the exact same thing as:&lt;/p&gt;
&lt;div class=&quot;language-nasm highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;_same&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;mov&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ECX&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0xAB&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;_done&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;retn&lt;/span&gt; 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Because jumping to the next instruction is, well, exactly what the processor does by default.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;HOWEVER&lt;/strong&gt;. A key component of “good” code usually is &lt;em&gt;consistency&lt;/em&gt;. If you have three chunks of code that are &lt;em&gt;supposed&lt;/em&gt; to do similar things, you should make them &lt;em&gt;look&lt;/em&gt; very similar. Even if it works just fine, removing that &lt;code class=&quot;highlighter-rouge&quot;&gt;jmp _done&lt;/code&gt; line forces the next person looking at your code to stop and think “Wait, why is this one different? Is that OK? Is this actually a bug?” and then a little while later come to the same conclusion as the original author did that, no, this still works fine. But, that was just some time that was wasted. Obviously, in a small case like this, it’s pretty easy to see and prove the equivalency. But, as you write more and more (and bigger and bigger) code, making a similar determination is not nearly as trivial. Best practice is to keep similar things as similar as possible.&lt;/p&gt;

&lt;p&gt;Finally. It should be noted that lots of other instructions set the &lt;em&gt;EFLAGS&lt;/em&gt; register - most math and logic operations, actually. Always check the manual. However, you can use this to skip the &lt;code class=&quot;highlighter-rouge&quot;&gt;cmp&lt;/code&gt; instruction sometimes. Doing so will produce smaller and faster code, though sometimes at the loss of readability…. sometimes. Buyer beware.&lt;/p&gt;

&lt;h2 id=&quot;what-we-skipped&quot;&gt;What We Skipped&lt;/h2&gt;

&lt;p&gt;Ok, so this should be enough for now - we’ll be able to move on to explain the basics of how C code turns into bits. Of course, there is … a lot … more to x86 than what we’ve discussed here. The biggest thing we’ve left out is how you create chunks of code that can be called from anywhere, and return back where they came from when done (&lt;em&gt;functions&lt;/em&gt;, for the folks who know about them already). Suffice to say, x86 has specific built in hardware support for making this happen, and we’ll probably hit it in a later blog post. No matter, it won’t be critical for the immediate discussion.&lt;/p&gt;

&lt;p&gt;Similarly, there’s a whole discussion to be had as to how an x86 processor allows certain code to be “privileged” or “unprivileged”, and keeps various chunks of code isolated from each other. We’ve also completely ignored how and why the code we’re writing shows up in “.exe” files, and how said “.exe” file happens to end up with its contents on the processor. These are all inter-related topics, which hopefully we’ll touch on when we discuss how operating systems work. Again suffice to say, it won’t be required to go through now, but keep in mind that the onion still has more layers&lt;/p&gt;

&lt;h2 id=&quot;next-steps---where-are-we-going&quot;&gt;Next Steps - Where are we going?&lt;/h2&gt;

&lt;p&gt;With the end of this post, hopefully we’ve presented a decent introduction to the bare-bones components of x86, a real assembly language that works on real processors. We’ll use this knowledge to help deconstruct how our high level language (C code) gets converted to 1’s and 0’s on a processor, with x86 assembly as the intermediate description of the bits. Coming soon!&lt;/p&gt;

&lt;div class=&quot;footnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:1&quot;&gt;
      &lt;p&gt;When I say workhorse, I really do mean it works hard, and can do a lot! Turns out, &lt;a href=&quot;https://youtu.be/R7EEoWg6Ekk?t=39&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;mov&lt;/code&gt; by itself is &lt;em&gt;Turing Complete&lt;/em&gt;&lt;/a&gt;. That’s right, you could build a computer that only know how to do &lt;code class=&quot;highlighter-rouge&quot;&gt;mov&lt;/code&gt;, or limit yourself to only using &lt;code class=&quot;highlighter-rouge&quot;&gt;mov&lt;/code&gt;, and still be able to &lt;em&gt;compute anything you want to&lt;/em&gt;. And even more so, &lt;a href=&quot;https://github.com/xoreaxeaxeax/movfuscator&quot;&gt;&lt;em&gt;someone did it&lt;/em&gt;&lt;/a&gt;. Seriously, this is one of my favorite exercises in all of computer science, just for its simultaneous absurdity and technical prowess. The video is long, but actually worthwhile, and totally approachable to someone who has kept pace with this blog thus far! &lt;a href=&quot;#fnref:1&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;</content><author><name></name></author><summary type="html">“It is well-known that the x86 instruction set is baroque, overcomplicated, and redundantly redundant.” - Stephen Dolan</summary></entry><entry><title type="html">Programming Language - C Syntax</title><link href="/blog_posts/2019/07/28/programming_language_c_syntax.html" rel="alternate" type="text/html" title="Programming Language - C Syntax" /><published>2019-07-28T09:31:00-05:00</published><updated>2019-07-28T09:31:00-05:00</updated><id>/blog_posts/2019/07/28/programming_language_c_syntax</id><content type="html" xml:base="/blog_posts/2019/07/28/programming_language_c_syntax.html">&lt;p&gt;&lt;em&gt;C is quirky, flawed, and an enormous success. - &lt;a href=&quot;https://en.wikipedia.org/wiki/Dennis_Ritchie&quot;&gt;Dennis Ritchie, co-creator of the C programming language&lt;/a&gt;.&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&quot;introduction&quot;&gt;Introduction&lt;/h2&gt;

&lt;p&gt;In this post, we’ll explain the basics of the C programming language syntax, showing how it accomplishes the major goals of any high-level programming language.&lt;/p&gt;

&lt;h2 id=&quot;the-c-like-syntax&quot;&gt;The “C-like” Syntax&lt;/h2&gt;

&lt;p&gt;Though we’re about to describe software syntax for the C programming language, the implications of these facts and examples are much broader.&lt;/p&gt;

&lt;p&gt;Many of the concepts C introduced in how a high-level language is to specify program behavior were inherited into other programming languages. For this reason, many languages are said to have “C-like syntax”, meaning that the fundamental way you specify behavior follows lots of the same design patterns laid out by C. The lion’s share of commonly used programming languages follow these patterns, so it seems to be a good place to start!&lt;/p&gt;

&lt;p&gt;For most of the readers of this blog, I’m assuming you have some casual familiarity with how to write software. But even if not, don’t worry - we’re going to go through the basics, again using a ground-up format to explain how computer programs are put together.&lt;/p&gt;

&lt;h3 id=&quot;storage-of-source-code&quot;&gt;Storage of Source Code&lt;/h3&gt;

&lt;p&gt;C code source files are just plain-text, ASCII or utf-encoded &lt;a href=&quot;https://en.wikipedia.org/wiki/Text_file&quot;&gt;text files&lt;/a&gt;, which just happen to have extensions like &lt;code class=&quot;highlighter-rouge&quot;&gt;.c&lt;/code&gt; or &lt;code class=&quot;highlighter-rouge&quot;&gt;.h&lt;/code&gt;. They can be opened and edited by any text editor: &lt;a href=&quot;https://code.visualstudio.com/&quot;&gt;VS Code&lt;/a&gt;, &lt;a href=&quot;https://notepad-plus-plus.org/&quot;&gt;Notepad++&lt;/a&gt;, &lt;a href=&quot;https://www.vim.org/&quot;&gt;VIM&lt;/a&gt;, &lt;a href=&quot;https://www.gnu.org/software/emacs/&quot;&gt;Emacs&lt;/a&gt;, even the built-in Windows Notepad (not recommended).&lt;/p&gt;

&lt;p&gt;A word to the wise - choose a good text editor which knows about C code syntax, so it can properly &lt;a href=&quot;https://en.wikipedia.org/wiki/Syntax_highlighting&quot;&gt;highlight different parts of each line&lt;/a&gt;. These visual cues are invaluable as a software developer to visualize the behavior of your code.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/syntaxHighlighting.png&quot; alt=&quot;Syntax Highlighting&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;c-code-statements--their-components&quot;&gt;C Code Statements &amp;amp; Their Components&lt;/h3&gt;

&lt;p&gt;Programs are fundamentally built up of a series individual statements. Each statement may contain directions to perform one or more of the common abilities of programming languages.&lt;/p&gt;

&lt;p&gt;Every statement has some content, and is terminated by a semicolon (&lt;code class=&quot;highlighter-rouge&quot;&gt;;&lt;/code&gt;). It’s just like putting a period at the end of your sentences. We use semicolons instead of periods because some numbers have periods inside them (ex: &lt;code class=&quot;highlighter-rouge&quot;&gt;3.14159&lt;/code&gt;), and using a unique symbol for unique meaning is easier than having to use the context around the symbol to determine meaning.&lt;/p&gt;

&lt;p&gt;Here is an example of a simple statement:&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;result = 3 + 5.7 * input;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;We will use this for reference as we go forward in the next few sections.&lt;/p&gt;

&lt;h4 id=&quot;constants&quot;&gt;Constants&lt;/h4&gt;

&lt;p&gt;C syntax allows software writers to use numbers in statements. THese numbers can be simple integers, like &lt;code class=&quot;highlighter-rouge&quot;&gt;3&lt;/code&gt; in the sample statement. They can also be fractional or &lt;em&gt;floating point&lt;/em&gt; numbers, such &lt;code class=&quot;highlighter-rouge&quot;&gt;5.7&lt;/code&gt; in the sample statement.&lt;/p&gt;

&lt;p&gt;A single negative sign (&lt;code class=&quot;highlighter-rouge&quot;&gt;-&lt;/code&gt;) in front of a number will of course make it negative - &lt;code class=&quot;highlighter-rouge&quot;&gt;-26&lt;/code&gt; is an allowed constant, equal to negative twenty six.&lt;/p&gt;

&lt;h4 id=&quot;variables&quot;&gt;Variables&lt;/h4&gt;

&lt;p&gt;C syntax also allows you to define names for memory locations. By using the name in a statement, the contents of that memory location will be used. Since a memory location can generally hold a range of numbers, these named memory locations act just like the variables in algebra. Therefor, we call them &lt;em&gt;variables&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;In the statement above, &lt;code class=&quot;highlighter-rouge&quot;&gt;input&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;result&lt;/code&gt; are both variables.&lt;/p&gt;

&lt;p&gt;Note that C does not allow variables to simply come into existence and disappear at runtime - each variable that is required must be &lt;em&gt;declared&lt;/em&gt; prior to usage. The precise manner in how you declare the variable will dictate how many bits are used to store values, whether the value is read/write or read-only, which portions of code are allowed to access the variable, and a whole slew of other properties.&lt;/p&gt;

&lt;p&gt;Built into the C programming language are a few basic variable types:&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;int&lt;/code&gt; is the basic integer storage. It is interpreted as a 2’s compliment signed integer.
&lt;code class=&quot;highlighter-rouge&quot;&gt;char&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;short&lt;/code&gt; both store integers as well, but take up fewer bits than &lt;code class=&quot;highlighter-rouge&quot;&gt;int&lt;/code&gt; (and therefore have a more restricted range).
&lt;code class=&quot;highlighter-rouge&quot;&gt;long&lt;/code&gt; will also be an integer, but take more bits than &lt;code class=&quot;highlighter-rouge&quot;&gt;int&lt;/code&gt; (and therefore have a wider range`).&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;char&lt;/code&gt; is usually treated as unsigned by default. Any type can get the qualifier &lt;code class=&quot;highlighter-rouge&quot;&gt;unsigned&lt;/code&gt; put in front of it to force it to be unsigned.&lt;/p&gt;

&lt;p&gt;The exact number of bits for each of these is not fixed - it depends on what type of processor you are on. This is incredibly horrible when attempting to write code that works the same on multiple machines, so other types like &lt;code class=&quot;highlighter-rouge&quot;&gt;int8_t&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;int16_t&lt;/code&gt;, and &lt;code class=&quot;highlighter-rouge&quot;&gt;int32_t&lt;/code&gt; are actually better to use - these explicitly specify the bit width.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;double&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;float&lt;/code&gt; are both floating point representations, allowing you to store decimal values.&lt;/p&gt;

&lt;p&gt;A number of other types are built in, and the keyword &lt;code class=&quot;highlighter-rouge&quot;&gt;typedef&lt;/code&gt; even allows you to define your own!&lt;/p&gt;

&lt;h4 id=&quot;assignment&quot;&gt;Assignment&lt;/h4&gt;

&lt;p&gt;Once we have variables, we have to have a way to get information into them. In C code statements, the &lt;code class=&quot;highlighter-rouge&quot;&gt;=&lt;/code&gt; equals sign character is used to perform an assignment operation. Assignment takes whatever is on the right-hand side of the &lt;code class=&quot;highlighter-rouge&quot;&gt;=&lt;/code&gt;, and places it into the variable on the left-hand side.&lt;/p&gt;

&lt;p&gt;It’s roughly equivalent to a “store” operation, rather than an expression of equality (more on that later). Think of it as memory movement - you do some calculation to get a number. Then, the equals sign indicates the calculation’s result needs to be stored somewhere. The variable on the left hand side provides the memory address where the value is to be stored at.&lt;/p&gt;

&lt;p&gt;In the sample statement above, the value calculated on the right-hand side of the &lt;code class=&quot;highlighter-rouge&quot;&gt;=&lt;/code&gt; is being stored into the variable named &lt;code class=&quot;highlighter-rouge&quot;&gt;result&lt;/code&gt; - and by this, we really mean the value is being put into the RAM memory bits associated with the variable &lt;code class=&quot;highlighter-rouge&quot;&gt;result&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;For example, combining our knowledge of Variables and Assignment:&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;var1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;25&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;var2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;32&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;var3&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;128&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;var4&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;534&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;574029&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;var5&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;23&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Will do weird stuff.&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;short&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;var6&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;67&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Will also do weird stuff.&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;operators&quot;&gt;Operators&lt;/h4&gt;

&lt;p&gt;On the right-hand side of any &lt;code class=&quot;highlighter-rouge&quot;&gt;=&lt;/code&gt; sign is a set of operations which perform the actual calculation of interest. C syntax reserves a set of characters for performing this calculation. There are a few broad categories of Operators.&lt;/p&gt;

&lt;h5 id=&quot;combining-numbers-with-math&quot;&gt;Combining Numbers with Math&lt;/h5&gt;

&lt;p&gt;Some common math functions are implemented:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;+&lt;/code&gt; adds the thing on the left and on the right of the symbol together&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;*&lt;/code&gt; multiplies the thing on the left and on the right of the symbol together&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-&lt;/code&gt; subtracts the thing on right from the thing on the left of the symbol&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;/&lt;/code&gt; divides the thing on the left by the thing on the right of the symbol&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;In the example above, the statement says to first multiply the value stored in the variable &lt;code class=&quot;highlighter-rouge&quot;&gt;input&lt;/code&gt; by &lt;code class=&quot;highlighter-rouge&quot;&gt;5.7&lt;/code&gt;, then add &lt;code class=&quot;highlighter-rouge&quot;&gt;3&lt;/code&gt; to the value. Finally, as already mentioned, that calculated value gets stored in &lt;code class=&quot;highlighter-rouge&quot;&gt;result&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Normal order of operations does apply here (mult/div, then add/subtract). Parenthesis &lt;code class=&quot;highlighter-rouge&quot;&gt;( )&lt;/code&gt; can be used to group operations if a different operation order is required.&lt;/p&gt;

&lt;p&gt;For example, the statement &lt;code class=&quot;highlighter-rouge&quot;&gt;result = (3 + 5.7) * input;&lt;/code&gt; simply multiplies &lt;code class=&quot;highlighter-rouge&quot;&gt;input&lt;/code&gt; by &lt;code class=&quot;highlighter-rouge&quot;&gt;8.7&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;There are some “specialty” math functions that C also defines. These aren’t strictly necessary, but provide useful shortcuts:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;variable++&lt;/code&gt; will &lt;em&gt;change&lt;/em&gt; the value stored in &lt;code class=&quot;highlighter-rouge&quot;&gt;variable&lt;/code&gt; by adding 1 to it. This is called “incrementing” the variable.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;variable--&lt;/code&gt; will &lt;em&gt;change&lt;/em&gt; the value stored in &lt;code class=&quot;highlighter-rouge&quot;&gt;variable&lt;/code&gt; by subtracting 1 from it. This is called “decrementing” the   variable.
    &lt;ul&gt;
      &lt;li&gt;Note &lt;code class=&quot;highlighter-rouge&quot;&gt;++&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;--&lt;/code&gt; operators perform an &lt;em&gt;assignment&lt;/em&gt; without an explicit &lt;code class=&quot;highlighter-rouge&quot;&gt;=&lt;/code&gt;. This is different than other math operators.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;The &lt;code class=&quot;highlighter-rouge&quot;&gt;%&lt;/code&gt; symbol is called the &lt;em&gt;modulo&lt;/em&gt; operator - it calculates the remainder after division.
    &lt;ul&gt;
      &lt;li&gt;For example, &lt;code class=&quot;highlighter-rouge&quot;&gt;7 % 5&lt;/code&gt; equals to 2 (since 7 divided by 5 is 1, remainder 2).&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;combining-bits-with-boolean-logic&quot;&gt;Combining Bits with Boolean Logic&lt;/h5&gt;

&lt;p&gt;C syntax also allows you to perform the basic boolean operations &lt;a href=&quot;/blog_posts/2019/06/14/boolean_logic.html&quot;&gt;we described earlier&lt;/a&gt;. Just like regular math, special symbols are reserved to indicate the operation.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;amp;&amp;amp;&lt;/code&gt; performs the AND operation between two values&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;||&lt;/code&gt; performs the OR operation between  two values
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;|&lt;/code&gt; is the symbol on the key right below backspace, accessed when you hit shift.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;!&lt;/code&gt; performs the NOT operation on a single value&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;All of these are called the “Logical” operators, since they treat their numbers like a single boolean value. The reason we say “treat” is because C doesn’t have a dedicated “boolean” type - the best we can do is just use one byte (named &lt;code class=&quot;highlighter-rouge&quot;&gt;char&lt;/code&gt;, as we will see later). Given these bite-sized variables, the value of &lt;code class=&quot;highlighter-rouge&quot;&gt;0&lt;/code&gt; is treated as FALSE, while any other value is TRUE. As it turns out, these are the more commonly used set of boolean operators.&lt;/p&gt;

&lt;p&gt;Lesser used, but worth a mention, are the &lt;em&gt;bitwise&lt;/em&gt; operators - they do the same boolean operation, but work bit-by-bit on the number. For example, the bitwise-NOT of &lt;code class=&quot;highlighter-rouge&quot;&gt;0b1100&lt;/code&gt; is &lt;code class=&quot;highlighter-rouge&quot;&gt;0b0011&lt;/code&gt; (note how each bit is flipped to the opposite value). Similarly, the bitwise-OR of &lt;code class=&quot;highlighter-rouge&quot;&gt;0b1100&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;0b0101&lt;/code&gt; is &lt;code class=&quot;highlighter-rouge&quot;&gt;0b1101&lt;/code&gt; (each bit in the first number OR’ed with the corresponding bit in the second number).&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;amp;&lt;/code&gt; performs the bitwise AND operation between two numbers&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;|&lt;/code&gt; performs the bitwise OR operation between two numbers&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;~&lt;/code&gt; performs the bitwise NOT on a number.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;See examples of the usage of these things later on. The key for now - these operators provide ways of combining boolean values to create new boolean values.&lt;/p&gt;

&lt;h5 id=&quot;creating-boolean-values-from-numbers-with-comparison&quot;&gt;Creating Boolean values from Numbers with Comparison&lt;/h5&gt;

&lt;p&gt;Just like in math that you’ve probably done in high school, there are a set of operators that will do comparison between two integer numbers to create boolean values. These operators do almost exactly what you would expect:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;gt;&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;gt;=&lt;/code&gt; check if one number is greater than (or equal to) another number.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;=&lt;/code&gt; check if one number is less than (or equal to) another number.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;==&lt;/code&gt; will check if two numbers are exactly equal&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;!=&lt;/code&gt; will check if two numbers are not equal&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Note this distinction between the action of &lt;code class=&quot;highlighter-rouge&quot;&gt;=&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;==&lt;/code&gt;, it’s a very common thing that gets lots of new software developers. &lt;code class=&quot;highlighter-rouge&quot;&gt;=&lt;/code&gt; performs &lt;em&gt;assignment&lt;/em&gt; - it takes one number and stores it into a memory address. &lt;code class=&quot;highlighter-rouge&quot;&gt;==&lt;/code&gt; performs &lt;em&gt;comparison&lt;/em&gt; - it checks whether two numbers are equal or not, creating a boolean from the result.&lt;/p&gt;

&lt;h4 id=&quot;comments&quot;&gt;Comments&lt;/h4&gt;

&lt;p&gt;Some special statements are called &lt;em&gt;comments&lt;/em&gt;. These are wrapped in special characters that tell the compiler to completely ignore the statement. The statement is only there to help human beings.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;// Some comments begin with two slashes&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;/* Others are between slash and star sequences */&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Put comments wherever you want to remember (or tell the next developer) what your code is doing. Use comments to describe the “why”, and not the “what”.&lt;/p&gt;

&lt;h3 id=&quot;grouping&quot;&gt;Grouping&lt;/h3&gt;

&lt;p&gt;A flat list of instructions is just fine for a computer, but generally humans like to visually organize their code a bit more. Therefor, in most programming languages, &lt;em&gt;statements&lt;/em&gt; are grouped together into clumps called &lt;em&gt;blocks&lt;/em&gt; based on the functionality that is desired.&lt;/p&gt;

&lt;h4 id=&quot;blocks&quot;&gt;Blocks&lt;/h4&gt;

&lt;p&gt;A &lt;em&gt;block&lt;/em&gt; of code is simply a logical subset of statements which form one cohesive action, and are meant to be run together. &lt;em&gt;Which&lt;/em&gt; statements belong together and &lt;em&gt;why&lt;/em&gt; will be discussed in due time, but for now consider just that statements will be grouped into units called &lt;em&gt;blocks&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;C code uses the symbols &lt;code class=&quot;highlighter-rouge&quot;&gt;{&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;}&lt;/code&gt; to mark the start and end of each block. By convention, the contents of the block are indented with whitespace by some amount (the author is a &lt;a href=&quot;https://stackoverflow.blog/2017/06/15/developers-use-spaces-make-money-use-tabs/&quot;&gt;strong advocate for 4 spaces&lt;/a&gt;).&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// This is the start of a block&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// Here is some code&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;25&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;input&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;output&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b00001111&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// This is the end of a block of code.&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Note that multiple blocks can be nested together:&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// start of outer block&lt;/span&gt;
  
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// Inner block 1&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// Inner block 2&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  
    &lt;span class=&quot;c1&quot;&gt;// end of outer block&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Blocks are used to group pieces of code together to defining when certain parts of logic should be executed or skipped based on conditions (&lt;em&gt;conditional flow&lt;/em&gt;), or for doing a chunk of code multiple times (&lt;em&gt;Releating Flow&lt;/em&gt;).&lt;/p&gt;

&lt;h4 id=&quot;grouping-for-conditional-flow&quot;&gt;Grouping for Conditional Flow&lt;/h4&gt;

&lt;p&gt;In C, you can use a set of statement as a prefix to a block, to define conditions on which the block should be run. The prefix statement must use some value or quantity that resolve to a boolean. Then, when the boolean is True, the block is executed. Otherwise, the block is skipped.&lt;/p&gt;

&lt;p&gt;The basic syntax for the prefix is &lt;code class=&quot;highlighter-rouge&quot;&gt;if(&amp;lt;condition&amp;gt;) { &amp;lt;code to execute&amp;gt; }&lt;/code&gt;. For a more concrete example:&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;condition&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;TRUE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;condition&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// This code will be run.&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;condition&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;FALSE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;condition&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// Now this code will be skipped.&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;C also provides a few other tools for making more complex combinations of these if- blocks. The &lt;code class=&quot;highlighter-rouge&quot;&gt;else&lt;/code&gt; statement is the alternative to &lt;code class=&quot;highlighter-rouge&quot;&gt;if&lt;/code&gt; - when &lt;code class=&quot;highlighter-rouge&quot;&gt;if&lt;/code&gt;’s condition is false, then the code for &lt;code class=&quot;highlighter-rouge&quot;&gt;else&lt;/code&gt; is run instead. Concretely:&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;condition&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;TRUE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;condition&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// This code will be run.&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// This code will be skipped.&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;condition&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;FALSE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;condition&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// Now this code will be skipped.&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// and this code will be run.&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;There is one more construct, which allows you to stack many if statements together, if the conditions should be mutually exclusive (zero or one are true), or a priority is needed (if multiple conditions are true, only one is acted on).&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;condition1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;TRUE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;condition2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;TRUE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;condition1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// This code will be run.&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;condition2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// This code will be skipped, since we &quot;hit&quot; the condition1 statement first.  &lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// This code will be skipped.&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;condition1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;FALSE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;condition2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;TRUE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;condition1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// This code will be skipped&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;condition2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// This code will be run&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// This code will be skipped.&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;As we go forward we will see more and more practical examples of this usage, so don’t worry too much about understanding the nuance and memorizing it now. Just keep in mind that there is a construct that uses &lt;code class=&quot;highlighter-rouge&quot;&gt;if&lt;/code&gt; to control if certain pieces of code get executed or not!&lt;/p&gt;

&lt;h4 id=&quot;grouping-for-repeating-flow&quot;&gt;Grouping for Repeating Flow&lt;/h4&gt;

&lt;p&gt;The other common usage for grouping blocks of statements is for when you want to have a chunk of code repeat many times over and over. Admittedly this is less common for robots, but still happens. As a simple example, say you had 20 numbers you wanted to print to the screen - using loops, you can use the same print code many times, minimizing the amount of copy/paste or rewrite work you have to do.&lt;/p&gt;

&lt;p&gt;A block of code which is run many times over and over is called a &lt;em&gt;loop&lt;/em&gt;. There are two main types of loops available in C.&lt;/p&gt;

&lt;p&gt;The &lt;em&gt;while&lt;/em&gt; loop repeats a chunk of code so long as a condition is TRUE. The syntax used in C is &lt;code class=&quot;highlighter-rouge&quot;&gt;while(&amp;lt;condition&amp;gt;) { &amp;lt;code to repeat&amp;gt; }&lt;/code&gt;. In a more concrete example:&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;condition&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;TRUE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;counter&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;condition&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;//Code to repeat&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;counter&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;condition&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;FALSE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;counter&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;If you trace the code execution, you should see that the code on the inside of the while loop runs until our counter is 10 or larger. THe counter starts at 0, and gets incremented every loop until we exit.&lt;/p&gt;

&lt;p&gt;The condition of &lt;code class=&quot;highlighter-rouge&quot;&gt;counter &amp;gt;= 10&lt;/code&gt; is referred to as the &lt;em&gt;terminal condition&lt;/em&gt; of the loop - it’s the condition which triggers the loop to stop running, and allows execution to continue past the final &lt;code class=&quot;highlighter-rouge&quot;&gt;}&lt;/code&gt; of the block.&lt;/p&gt;

&lt;p&gt;Now, of course, &lt;code class=&quot;highlighter-rouge&quot;&gt;condition&lt;/code&gt; doesn’t have to be tied to a fixed number of loops - it could be some event on the robot (like receiving a packet over ethernet) or user interaction (driver pushes a button), for example. But for when you are looking to run for a set number of loops, there is a syntax which allows expressing it more concisely.&lt;/p&gt;

&lt;p&gt;Enter the &lt;em&gt;for&lt;/em&gt; loop in C. It looks way more complex than it actually is. For loops are used when you know the exact number of times you want to iterate, rather than simply &lt;em&gt;wait&lt;/em&gt; for some external event (for an unknown duration).&lt;/p&gt;

&lt;p&gt;Just like &lt;em&gt;while&lt;/em&gt; loops, &lt;em&gt;for&lt;/em&gt; loops cause a block of code to get executed many times. The prefix to that block has extra syntax to provide a concise way of describing how long you will loop for.&lt;/p&gt;

&lt;p&gt;This syntax is &lt;code class=&quot;highlighter-rouge&quot;&gt;for(&amp;lt;init action&amp;gt;; &amp;lt;loop condition&amp;gt;; &amp;lt;loop action&amp;gt;){ &amp;lt;Code to be executed&amp;gt; }&lt;/code&gt;. THe Init action is simply a statement to be done right before starting the loop, and the loop action is a statement to be run at the end of the loop.&lt;/p&gt;

&lt;p&gt;99% of the time, &lt;em&gt;for&lt;/em&gt; loops will be written something like this:&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;idx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;idx&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;idx&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;idx&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// This code runs 10 times&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The sequence of steps that is summarized all in that one line:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Before running anything inside the loop, &lt;code class=&quot;highlighter-rouge&quot;&gt;idx&lt;/code&gt; is set to &lt;code class=&quot;highlighter-rouge&quot;&gt;0&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;Every loop, before doing the contents of loop, we check if the condition &lt;code class=&quot;highlighter-rouge&quot;&gt;idx &amp;lt; 10&lt;/code&gt; evaluates to TRUE. This happens for the first 10 loops, but not for any subsequent one.&lt;/li&gt;
  &lt;li&gt;After running the contents of the loop, we perform the action &lt;code class=&quot;highlighter-rouge&quot;&gt;idx++&lt;/code&gt;, which keeps idx up to date with the number of times we have completed the loop action.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;In C, the &lt;em&gt;for&lt;/em&gt; loop is pure syntactical candy. There’s no reason you can’t do the exact same thing with a while loop:&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;idx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;idx&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;idx&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// This code runs 10 times&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;idx&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;However, that takes two extra lines. Since this pattern is very common, the C language built in the &lt;em&gt;for&lt;/em&gt; loop shortcut.&lt;/p&gt;

&lt;p&gt;We’ll get into more of the nuances of how to make the choice between &lt;em&gt;for&lt;/em&gt; and &lt;em&gt;while&lt;/em&gt; in future posts.&lt;/p&gt;

&lt;h4 id=&quot;grouping-for-reusability&quot;&gt;Grouping for Reusability&lt;/h4&gt;

&lt;p&gt;Another major usage of blocks of instructions is to create reusable chunks of code which perform a specific subset of functionality. In C code, we refer to such blocks of code as &lt;em&gt;functions&lt;/em&gt;. A function is simply a block of code with a specific prefix to create the name of the function, specify what inputs it has (the &lt;em&gt;arguments&lt;/em&gt;), and define the type of output (the &lt;em&gt;return value&lt;/em&gt;) it has.&lt;/p&gt;

&lt;p&gt;Generally, the syntax for creating a function is:&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;return type&amp;gt; &amp;lt;function name&amp;gt;(&amp;lt;arguments&amp;gt;){ &amp;lt;contents of function&amp;gt;}&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Functions should generally perform one monolithic task, and one task alone.&lt;/p&gt;

&lt;p&gt;For example, let’s create a function with calculates the square of some input number, but preserves the sign of the number. This is a common operation done while conditioning joystick inputs from a driver - it gives them less sensitivity near the center for precise slow motions.&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;squareSigned&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;in&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;in&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;In painstaking detail, here’s what the handful of lines of code actually mean:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;The function is first declared. &lt;code class=&quot;highlighter-rouge&quot;&gt;double squareSigned&lt;/code&gt; says “There is a function named &lt;code class=&quot;highlighter-rouge&quot;&gt;squareSigned&lt;/code&gt; which returns a value of type &lt;code class=&quot;highlighter-rouge&quot;&gt;double&lt;/code&gt;”.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;squareSigned(double in){&lt;/code&gt; says “Function &lt;code class=&quot;highlighter-rouge&quot;&gt;squareSigned&lt;/code&gt; takes one argument named &lt;code class=&quot;highlighter-rouge&quot;&gt;in&lt;/code&gt;, which must be of type &lt;code class=&quot;highlighter-rouge&quot;&gt;double&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;Whenever &lt;code class=&quot;highlighter-rouge&quot;&gt;squareSigned&lt;/code&gt; is run, the first step is to set aside some memory to keep track of the result while we’re performing the operation. We’ll refer to that memory with the name &lt;code class=&quot;highlighter-rouge&quot;&gt;result&lt;/code&gt;, treating it as a double floating point value.&lt;/li&gt;
  &lt;li&gt;The first real step calculation is to multiply &lt;code class=&quot;highlighter-rouge&quot;&gt;in&lt;/code&gt; by itself, and store that into &lt;code class=&quot;highlighter-rouge&quot;&gt;result&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;After we have the value of &lt;code class=&quot;highlighter-rouge&quot;&gt;in * in&lt;/code&gt; stored into &lt;code class=&quot;highlighter-rouge&quot;&gt;result&lt;/code&gt;, we now need to re-apply the sign of &lt;code class=&quot;highlighter-rouge&quot;&gt;in&lt;/code&gt; (since squaring it always produces a positive value).&lt;/li&gt;
  &lt;li&gt;We calculate whether in was negative or not by comparing it to zero with the statement &lt;code class=&quot;highlighter-rouge&quot;&gt;in &amp;lt; 0&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;If &lt;code class=&quot;highlighter-rouge&quot;&gt;in&lt;/code&gt; was in fact negative, we also need to make &lt;code class=&quot;highlighter-rouge&quot;&gt;result&lt;/code&gt; negative. To accomplish this, we use the &lt;em&gt;if&lt;/em&gt; statement to conditionally run our negating logic.&lt;/li&gt;
  &lt;li&gt;Within the &lt;code class=&quot;highlighter-rouge&quot;&gt;if(){&lt;/code&gt; block, multiply &lt;code class=&quot;highlighter-rouge&quot;&gt;result&lt;/code&gt; by negative one, and store it back into result. This means that &lt;code class=&quot;highlighter-rouge&quot;&gt;result&lt;/code&gt; will now have the same sign as &lt;code class=&quot;highlighter-rouge&quot;&gt;in&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;Finally, we specify that the value in &lt;code class=&quot;highlighter-rouge&quot;&gt;result&lt;/code&gt; is to be the return value of the function. With the statement &lt;code class=&quot;highlighter-rouge&quot;&gt;return result;&lt;/code&gt;, we return execution control to whatever chunk of code called this function in the first place, returning the value from &lt;code class=&quot;highlighter-rouge&quot;&gt;result&lt;/code&gt; at the same time.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Finally, keep in mind this is just one basic, contrived example, targeted at the first-time learner. We’ll get more into the “when” and “why” of function usage in later posts, but for now, just remember that such a tool for reusing functionality is available in any programming language worth its salt.&lt;/p&gt;

&lt;h2 id=&quot;miscellaneous-code-examples&quot;&gt;Miscellaneous Code Examples&lt;/h2&gt;

&lt;h3 id=&quot;boolean-values&quot;&gt;Boolean Values&lt;/h3&gt;

&lt;p&gt;A very common use-case of the bitwise operators is forcing a single bit to 1 or to 0 in a number. For example:&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;//Force the least-significant bit of value to 0, but leave the rest untouched.&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b11111110&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//Force the least-significant bit of value to 1, but leave the rest untouched.&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b00000001&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Another usecase is to check if a particular bit is 1 or 0:&lt;/p&gt;
&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// Check if the most-significant bit is set to 1&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;bit_is_set&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b10000000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;bit_is_set&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;// bit was 1&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;// bit was 0&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;In this example, the constant &lt;code class=&quot;highlighter-rouge&quot;&gt;0b10000000&lt;/code&gt; is referred to as the “bitmask” since it masks off all bits except the first one (aka forces the to 0). This way, if the top bit is zero, &lt;code class=&quot;highlighter-rouge&quot;&gt;bit_is_set&lt;/code&gt; will be non-zero, and can be used in the &lt;code class=&quot;highlighter-rouge&quot;&gt;if()&lt;/code&gt; statement to change the action of the program.&lt;/p&gt;

&lt;h3 id=&quot;using-functions&quot;&gt;Using Functions&lt;/h3&gt;

&lt;p&gt;Consider the &lt;code class=&quot;highlighter-rouge&quot;&gt;squareSigned()&lt;/code&gt; function we looked at earlier. Back in main robot code, this would get used in a fashion something like this:&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// ...&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;joyValue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;motValue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;joyValue&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;getDriverXJoystick&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;motValue&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;squareSigned&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;joyValue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;setLeftDriveMotor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;motValue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;setRightDriveMotor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;motValue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// ...&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;In this highly contrived example, we declare two variables to store the value of the joystick, and the value we want to power the motors at. We’ll assume that functions named &lt;code class=&quot;highlighter-rouge&quot;&gt;getDriverXJoystick()&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;setLeftDriveMotor()&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;setRightDriveMotor()&lt;/code&gt; exist and have been provided to us for interaction with the physical hardware. Our job is just to hook up one piece of hardware to another.&lt;/p&gt;

&lt;p&gt;Since this isn’t the only joystick on the robot, we’ll use our common &lt;code class=&quot;highlighter-rouge&quot;&gt;squareSigned()&lt;/code&gt; function to perform the desired mapping from a joystick reading to a motor command.&lt;/p&gt;

&lt;p&gt;In this example, we first populate our &lt;code class=&quot;highlighter-rouge&quot;&gt;joyValue&lt;/code&gt; with some value read in from the joysticks.&lt;/p&gt;

&lt;p&gt;We then pass that value into our function &lt;code class=&quot;highlighter-rouge&quot;&gt;squareSigned()&lt;/code&gt;, which transfers control of the program to that function. When the function is done with its transformation, its &lt;em&gt;return value&lt;/em&gt; is stored into our variable &lt;code class=&quot;highlighter-rouge&quot;&gt;motValue&lt;/code&gt;. We can then use &lt;code class=&quot;highlighter-rouge&quot;&gt;motValue&lt;/code&gt; as the command to send to both motors.&lt;/p&gt;

&lt;p&gt;Note that for these examples, we’ve chosen some very obvious names for our variables. Clearly, to any reasonably astute observer, &lt;code class=&quot;highlighter-rouge&quot;&gt;joyValue&lt;/code&gt; would tend to imply something along the lines of “value from a joystick”, and &lt;code class=&quot;highlighter-rouge&quot;&gt;motValue&lt;/code&gt; would imply “value for a motor”. This is intentional - choose meaningful names so its easier for you to remember exactly what each variable is for, when you come back and look at the code in 5 weeks and have no idea what it was doing.&lt;/p&gt;

&lt;p&gt;Of course, the compiler is not a human, and doesn’t know that the string of characters &lt;code class=&quot;highlighter-rouge&quot;&gt;joyValue&lt;/code&gt; has any real relationship to a joystick. No matter how good of names you choose for your variables, the compiler will still always expect you to populate them with meaningful values yourself - ie, call &lt;code class=&quot;highlighter-rouge&quot;&gt;getDriverXJoystick()&lt;/code&gt; and assign it into &lt;code class=&quot;highlighter-rouge&quot;&gt;joyValue&lt;/code&gt;. The above code could be written as:&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// ...&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;woodieFlowers&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;deanKamen&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;woodieFlowers&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;getDriverXJoystick&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;deanKamen&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;squareSigned&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;woodieFlowers&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;setLeftDriveMotor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;deanKamen&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;setRightDriveMotor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;deanKamen&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// ...&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;And it would work the exact same way. The only difference is you’ll be hating yourself in three days when you have no recollection what a &lt;code class=&quot;highlighter-rouge&quot;&gt;woodieFlowers&lt;/code&gt; is for.&lt;/p&gt;

&lt;h2 id=&quot;next-steps---where-are-we-going&quot;&gt;Next Steps - Where are we going?&lt;/h2&gt;

&lt;p&gt;We’re nearing the end of the story-arc for our introductory content! Next up, we’ll start exploring how these basic C constructs are accomplished on a real processor. This will be the last major building block in understanding, at a high level, how lines of code actually perform their action under the hood. &lt;a href=&quot;/blog_posts/2019/08/10/x86_intro.html&quot;&gt;To get started, check out our introduction to the x86 assembly language!&lt;/a&gt;&lt;/p&gt;</content><author><name></name></author><summary type="html">C is quirky, flawed, and an enormous success. - Dennis Ritchie, co-creator of the C programming language.</summary></entry><entry><title type="html">Programming Languages - Introduction</title><link href="/blog_posts/2019/07/28/programming_language_intro.html" rel="alternate" type="text/html" title="Programming Languages - Introduction" /><published>2019-07-28T09:30:00-05:00</published><updated>2019-07-28T09:30:00-05:00</updated><id>/blog_posts/2019/07/28/programming_language_intro</id><content type="html" xml:base="/blog_posts/2019/07/28/programming_language_intro.html">&lt;p&gt;&lt;em&gt;Let us change our traditional attitude to the construction of programs. Instead of imagining that our main task is to instruct a computer what to do, let us concentrate rather on explaining to human beings what we want a computer to do.  - &lt;a href=&quot;https://en.wikipedia.org/wiki/Donald_Knuth&quot;&gt;Donald Knuth&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&quot;introduction&quot;&gt;Introduction&lt;/h2&gt;

&lt;p&gt;This post marks our first “pure” venture into the world of software. As a start, we’ll level-set everyone on the programming language syntax we’ll need to all understand to move forward. This is a bit of an “aside” from our normal progression, but required to move forward effectively.&lt;/p&gt;

&lt;h3 id=&quot;on-our-selection-of-introductory-languages&quot;&gt;On our Selection of Introductory Languages&lt;/h3&gt;

&lt;h4 id=&quot;the-options&quot;&gt;The Options&lt;/h4&gt;

&lt;p&gt;In FRC land, there are a handful of different programming languages that are commonly supported. Labview is in its own special class. Aside from this, the big players are Java and C++, followed by Python and Kotlin. These are all powerful, professional, and (relatively) modern programming languages, each rich with its own features and quirks. For &lt;em&gt;FRC&lt;/em&gt; purposes, any of them make a fine choice for writing robot software.&lt;/p&gt;

&lt;p&gt;It should be noted that &lt;a href=&quot;https://www.chiefdelphi.com/t/c-or-java/358070&quot;&gt;people have opinions&lt;/a&gt; on the selection of programming languages.&lt;/p&gt;

&lt;h4 id=&quot;the-choice&quot;&gt;The Choice&lt;/h4&gt;

&lt;p&gt;In order to do the ground-up approach properly, we’re going to not start with any of these languages, but rather with pure C. This will simplify the connection between how bits are manipulated on a processor, and the actual code we write.  Additionally, once you understand the concepts of how C is put together, it becomes easy to see how the additional features provided by C++, Kotlin, Java, or Python could be implemented in C.&lt;/p&gt;

&lt;p&gt;In this way, by focusing on an understanding of how C code works on a processor, we provide a pathway for understanding how &lt;em&gt;any&lt;/em&gt; programming language works on a processor.&lt;/p&gt;

&lt;h3 id=&quot;high-level-vs-low-level&quot;&gt;High Level vs. Low Level&lt;/h3&gt;

&lt;p&gt;When describing programming languages, we’ve already used the description &lt;em&gt;high level&lt;/em&gt;. As you’d probably expect, &lt;em&gt;low level&lt;/em&gt; is also a description. Loosely, these terms describe “how close to the actual silicon of the processor are you?”. Closeness here refers to the number of layers of abstraction formally defined between the thing you are typing out on a keyboard, and the logic gates doing useful things in response to your typing.&lt;/p&gt;

&lt;p&gt;The literal 1’s and 0’s going through your processor is probably the lowest level way to write a program. The people who truly believe this is the best way to write software are either dead, or literally crazy.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/supercoder2000.jpg&quot; alt=&quot;expert keyboard&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;source - reddit.com&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Just barely one step up, we can represent these 1’s and 0’s with much more useful pneumonics, like ADD (addition), SUB (subtract), MOV (move), LD (load), ST (store), etc. Rather than forcing a human to remember that &lt;script type=&quot;math/tex&quot;&gt;0010001010011&lt;/script&gt; means “Add general purpose register 1 to general purpose register 2 and store the result in general purpose register 3”, we simply by writing something like &lt;strong&gt;ADD R1 R2 R3&lt;/strong&gt;. Isn’t that better than staring at &lt;script type=&quot;math/tex&quot;&gt;0010001010011&lt;/script&gt;? I think so. This abstraction to pneumonics is called &lt;em&gt;assembly code&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Depending on the application, it still makes sense to write code at this level. When you need very fast code, very efficient code, or very very precise code for working with specialized hardware, assembly is your go-to solution. And, if you know the hardware well, it’s admittedly not bad. Chris Sawyer wrote multiple video games using it &lt;a href=&quot;https://en.wikipedia.org/wiki/RollerCoaster_Tycoon_(video_game)&quot;&gt;nearly&lt;/a&gt; &lt;a href=&quot;https://en.wikipedia.org/wiki/RollerCoaster_Tycoon_2&quot;&gt;exclusively&lt;/a&gt;. People who like writing software here are still a special breed of folks, but not as crazy as the ones who have the ink on their 1 and 0 keys rubbed off from excessive usage.&lt;/p&gt;

&lt;p&gt;For the rest of us folks, we usually use some sort of &lt;em&gt;high level&lt;/em&gt; programming language. The official definition of a &lt;em&gt;High Level&lt;/em&gt; programming language is simply one that attempts to abstract away the details of &lt;em&gt;exactly&lt;/em&gt; which assembly instructions are supported or needed, and hide them behind a more generalized way of describing desired behavior. The key advantage of doing this is that you can write one program, and rely on different compiler tools to take that same source code, and emit assembly instructions which can work on many different types of computers. This interoperability is a key driver in lots of the design of high level languages, but comes at a cost - it is harder to interact with specific details of the hardware you are on, and inherently less efficient to execute code.&lt;/p&gt;

&lt;p&gt;It should be noted that you can always add more layers of abstraction. A language doesn’t have to transform into assembly code - you can transfom between high level languages too. For example, MathWorks’ &lt;em&gt;Simulink&lt;/em&gt; is a graphical programming language, much like Labview, which can &lt;a href=&quot;https://www.mathworks.com/help/dsp/ug/generate-c-code-from-simulink-model.html&quot;&gt;have its block diagrams converted directly to C code&lt;/a&gt;. In this way, you can say Simulink is a higher-level programming language than C.&lt;/p&gt;

&lt;p&gt;For specific use cases, there are other programming languages which can build into Simulink models.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://media.giphy.com/media/pyQV6sy5qOALu/giphy.gif&quot; alt=&quot;ogres are like onions&quot; /&gt;&lt;/p&gt;

&lt;p&gt;The layers just keep going.&lt;/p&gt;

&lt;p&gt;This is why large software projects often have to combine many programming languages together. Your ultimate goal is simply to describe to the computer what you want it to do. You always want your software development to take place at the highest-level that makes sense - this allows you to have to spend the least amount of time thinking about details that, at the end of the day, an automated tool could have done for you. Only get into the nitty-gritty when you have to. But when duty calls, don’t be afraid to dive deep.&lt;/p&gt;

&lt;h2 id=&quot;the-c-programming-language&quot;&gt;The C Programming Language&lt;/h2&gt;

&lt;h3 id=&quot;super-basics---what-does-a-programming-language-have-to-accomplish&quot;&gt;Super Basics - What does a Programming Language have to Accomplish?&lt;/h3&gt;

&lt;p&gt;Any programming language’s job is to bridge the worlds of human-readable description of behavior, to a machine-readable set of 1’s and 0’s that can flow through a processor. The &lt;em&gt;compiler&lt;/em&gt; is the tool that actually does the action, and the language’s &lt;em&gt;syntax&lt;/em&gt; is the set of rules on the compiler input to allow the action to work.&lt;/p&gt;

&lt;p&gt;Remember the compiler itself is a program, and can’t think creatively (or read your mind). The language &lt;em&gt;syntax&lt;/em&gt; is the agreed-upon rules that you will use to communicate information with the compiler.&lt;/p&gt;

&lt;p&gt;The syntax must be flexible enough to be Turing Complete, but constrained enough to not force the human to think about too many details.&lt;/p&gt;

&lt;p&gt;Good syntax design allows the programming language to describe all the calculations and logic required to establish a &lt;em&gt;relationship&lt;/em&gt; between &lt;em&gt;inputs&lt;/em&gt; and &lt;em&gt;outputs&lt;/em&gt;. At the end of the day, that’s really all your software on your robot has to do - map driver inputs, sensor inputs, and field state (teleop/auto) to motor and solenoid commands.&lt;/p&gt;

&lt;h4 id=&quot;abilities-common-to-all-programming-languages&quot;&gt;Abilities Common to all Programming Languages&lt;/h4&gt;

&lt;p&gt;To be useful, all programming languages have to have a few basic components:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Input &amp;amp; Output (IO)
    &lt;ul&gt;
      &lt;li&gt;Interacting with the “outside world”&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Assignment
    &lt;ul&gt;
      &lt;li&gt;Storing and retrieving data from memory (aka Variables)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Math &amp;amp; Logic
    &lt;ul&gt;
      &lt;li&gt;Combining numbers and true/false conditions&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Control flow
    &lt;ul&gt;
      &lt;li&gt;Using results of true/false conditions to control execution&lt;/li&gt;
      &lt;li&gt;Repeating instructions under certain conditions&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Structural Organization
    &lt;ul&gt;
      &lt;li&gt;Functions, Classes, objects, source files, interfaces, templates, etc.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;history&quot;&gt;History&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/C_(programming_language)#History&quot;&gt;The C programming language&lt;/a&gt; is the OG of high level languages. It wasn’t the first of its type, but it was by far the most successful. It struck just the right balance between providing nice high-level programming language abstractions, without getting so high level as to become convoluted and bloated with useless features.&lt;/p&gt;

&lt;p&gt;It was introduced in the late 1970’s, tightly tied with the development of the &lt;a href=&quot;https://en.wikipedia.org/wiki/Unix&quot;&gt;Unix operating system&lt;/a&gt; at &lt;a href=&quot;https://en.wikipedia.org/wiki/Bell_Labs&quot;&gt;Bell Labs&lt;/a&gt;. The initial goal was to provide a high-level language for writing utilities for the OS. It evolved quickly to be the language that the operating system itself was written in.&lt;/p&gt;

&lt;p&gt;The amazing thing is that as other languages have come and gone, C has remained the de-facto standard for anyone looking to write software with the highest performance, highest efficiency, or most hardware interaction. C++ and Rust are starting to supplant it in a few places, but C is still by far king for operating system and embedded system development. The fact any programming language has lasted these 40+ years is a true testament to good design.&lt;/p&gt;

&lt;h2 id=&quot;next-steps---where-are-we-going&quot;&gt;Next Steps - Where are we going?&lt;/h2&gt;

&lt;p&gt;In our next post, we will look into the details of the syntax of the C programming language, to see how it implements these components to accomplish the goals of a high-level programming language. See &lt;a href=&quot;/blog_posts/2019/07/28/programming_language_c_syntax.html&quot;&gt;C Syntax here&lt;/a&gt;.&lt;/p&gt;</content><author><name></name></author><summary type="html">Let us change our traditional attitude to the construction of programs. Instead of imagining that our main task is to instruct a computer what to do, let us concentrate rather on explaining to human beings what we want a computer to do. - Donald Knuth</summary></entry><entry><title type="html">Processor Architecture</title><link href="/blog_posts/2019/07/22/vonneumann.html" rel="alternate" type="text/html" title="Processor Architecture" /><published>2019-07-22T09:31:00-05:00</published><updated>2019-07-22T09:31:00-05:00</updated><id>/blog_posts/2019/07/22/vonneumann</id><content type="html" xml:base="/blog_posts/2019/07/22/vonneumann.html">&lt;p&gt;&lt;em&gt;People who are more than casually interested in computers should have at least some idea of what the underlying hardware is like. Otherwise the programs they write will be pretty weird. - &lt;a href=&quot;https://en.wikipedia.org/wiki/Donald_Knuth&quot;&gt;Donald Knuth&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&quot;introduction&quot;&gt;Introduction&lt;/h2&gt;

&lt;p&gt;Oooh boy, I am getting excited! More excited than a &lt;a href=&quot;https://en.wikipedia.org/wiki/File_Explorer#Search_companion&quot;&gt;search companion who can do tricks!&lt;/a&gt; Things are starting to get very real now!&lt;/p&gt;

&lt;p&gt;We’ve introduced a ton of topics in boolean logic - how to manipulate bits, store them, and use them to represent numbers. It’s time to start digging into how all this comes together to build a real device which can do computation!&lt;/p&gt;

&lt;h2 id=&quot;the-von-neumann-architecture&quot;&gt;The Von Neumann Architecture&lt;/h2&gt;

&lt;h3 id=&quot;overall&quot;&gt;Overall&lt;/h3&gt;

&lt;p&gt;Through his work, Von Neumann described a generic &lt;em&gt;architecture&lt;/em&gt; for how to construct and lay-out electronic components to fulfill Turing’s requirements. This description has been coined the “Von Neumann Architecture”. It should be noted that since almost all modern processors follow the architecture to some extent, the phrase “Von Neumann Architecture” actually refers more to the set of ideas, rather than one particular design.&lt;/p&gt;

&lt;p&gt;Von Neumann divided his world up into four very-high-level components:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Memory&lt;/strong&gt; - A device capable of saving and recalling pieces of information.
    &lt;ul&gt;
      &lt;li&gt;Might be broken into multiple parts
        &lt;ul&gt;
          &lt;li&gt;Read-only vs. Read/Write&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Roughly analogous to the “Tape” in the Turing Machine&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Processor Unit&lt;/strong&gt; - A device capable of performing a calculation on pieces of information.
    &lt;ul&gt;
      &lt;li&gt;Possible calculations:
        &lt;ul&gt;
          &lt;li&gt;Math (add subtract multiply divide etc.)&lt;/li&gt;
          &lt;li&gt;Logic (and or not)&lt;/li&gt;
          &lt;li&gt;Comparison (greater than, less than, equal to)&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Roughly equivalent to the “Head” in the Turing Machine&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Control Unit&lt;/strong&gt; - A device to provide coordination between all other units
    &lt;ul&gt;
      &lt;li&gt;Produces the control signals that configure all other units&lt;/li&gt;
      &lt;li&gt;Produces the &lt;em&gt;correct&lt;/em&gt; signals to implement the Universal Turing Machine&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;IO&lt;/strong&gt; - A set of devices capable of transforming information between representations useful to computers, and representations useful to humans.
    &lt;ul&gt;
      &lt;li&gt;Screens, mice, keyboards, etc.&lt;/li&gt;
      &lt;li&gt;Implementation is device specific, but the key is that on one end is an interface that works well with the computer (bits and bytes), and on the other end is a physical thing a human can manipulate or sense.&lt;/li&gt;
      &lt;li&gt;In our Turing Machine association, this is just the way a human can manipulate or interact with the device or the tape.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;processing-unit&quot;&gt;Processing Unit&lt;/h3&gt;

&lt;p&gt;Storing data is cool, but to do useful processing we have to, well, process the data. Back when we learned about boolean logic, we saw all sorts of ways to mash bits together. The goal now is to build a circuit which can do all the useful things for us.&lt;/p&gt;

&lt;p&gt;The collection of circuitry which does the calculations is generally referred to as the &lt;em&gt;Arithmetic Logic Unit&lt;/em&gt;, or ALU. It gets its own fancy-pants symbol that looks like a sideways pair of pants:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/ALU.png&quot; alt=&quot;ALU&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Implementations on various processors will vary slightly, but conceptually they all have to have at least 3 inputs:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;A and B - the operands. A and B are the binary numbers we’re going to mash together&lt;/li&gt;
  &lt;li&gt;CTRL - the signals that say &lt;em&gt;how&lt;/em&gt; to mash A and B together.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;And of course, the set of these three inputs produces the result of the requested calculation.&lt;/p&gt;

&lt;p&gt;Keeping with our 32-bit theme, we assume that the ALU is set up to do calculations on 32-bit inputs, and produces a 32-bit result. Other processors may assume otherwise, but this is just our example for now.&lt;/p&gt;

&lt;p&gt;CTRL can be any number of bits - it just depends on how many different ways you want to be able to combine the inputs A and B together. For example, if you have 12 combination strategies implemented, you’ll need &lt;script type=&quot;math/tex&quot;&gt;\lceil log_{2}(12) \rceil = 4&lt;/script&gt; bits.&lt;/p&gt;

&lt;p&gt;The simplest practical architecture I’ve seen has a very small ALU with only three operations supported:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Bitwise AND&lt;/li&gt;
  &lt;li&gt;Bitwise NOT&lt;/li&gt;
  &lt;li&gt;Addition&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;It’s pretty bare-bones. FOr example, to do &lt;script type=&quot;math/tex&quot;&gt;A - B&lt;/script&gt;, , you have to first negate the B operand (which requires a bitwise NOT, then adding 1), then adding A and (-B). Subtraction is a 3 step process, which kinda stinks.&lt;/p&gt;

&lt;p&gt;Larger ALU’s will support more operations, including:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Bitwise OR/NOR/NAND, Subtraction
    &lt;ul&gt;
      &lt;li&gt;Keeps common operations down to a single step&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Multiplication, Integer Division, Remainder after division
    &lt;ul&gt;
      &lt;li&gt;Expanded math abilities on integers&lt;/li&gt;
      &lt;li&gt;Note that floating point (decimal) numbers are frequently handled by a different unit&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Bitwise XOR
    &lt;ul&gt;
      &lt;li&gt;Super useful for cryptographic and computer security operations&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Shift bits left and right by one
    &lt;ul&gt;
      &lt;li&gt;super fast way to multiply or divide by 2&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Increment, decrement
    &lt;ul&gt;
      &lt;li&gt;Super-optimized versions of common math operations&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;What set of operations are supported really just depends on processor design. Increasing the number of supported operations increases speed to a point, but always at increased cost and increased potential for things to break.&lt;/p&gt;

&lt;p&gt;Conceptually, putting together an ALU is remarkably straightforward. Just package all the circuits which do the operations you want individually, feed them each off of the provided inputs, and use a MUX driven by the CTRL input to select which calculation makes it to the output.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/aluInternals.png&quot; alt=&quot;inside ALU&quot; /&gt;&lt;/p&gt;

&lt;p&gt;In addition to these combination operations, the ALU will often have additional outputs to indicate if the operation resulted in overflow or underflow (ie, result was outside the min or max range of the numbers that can be represented by the 32 bits of the ALU).&lt;/p&gt;

&lt;h3 id=&quot;control-unit&quot;&gt;Control Unit&lt;/h3&gt;

&lt;p&gt;The control unit is the heart of this whole system, coordinating the action of registers and the ALU together to do actual calculation. The design of the unit is special tailored to implement the stored-program concept. Again, the exact design of the control unit can vary, but all have to have at least a few basic components and abilities.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/controlUnit.png&quot; alt=&quot;Control Unit Top Level&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;registers&quot;&gt;Registers&lt;/h4&gt;

&lt;p&gt;Fundamentally, every control unit will have a set of registers to store information. These will be faster than the bulk RAM chips you’re familiar with, and serve special uses within the processor. But, fundamentally, they just store a specific set of bits representing some specific, meaningful quantity.&lt;/p&gt;

&lt;p&gt;The &lt;em&gt;Memory Address Register&lt;/em&gt; (MAR) and &lt;em&gt;Memory Data Register&lt;/em&gt; (MDR) are two of the key registers. They are connected directly to the RAM circuitry, and allow the control unit to command unit to read or write from a specific memory address. Along with a couple control signals, the basic process is that the memory address register is first loaded with the desired address. Then, control signals are sent to memory to read or write that address. For read, the data is pulled off the RAM chip and placed into the MDR. Write does similarly, but propagates whatever value was in the MDR (from the control unit’s other parts) and puts it into the address in RAM specified by the MAR. Using this, the control unit can &lt;em&gt;read and write RAM data&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Two more registers form the core of the stored program concept. The processor fundamentally assumes that the instructions it is supposed to execute exist in memory at a certain set of memory instructions. The &lt;em&gt;Program Counter&lt;/em&gt; (PC) register stores the memory address of the current instruction being worked on. The &lt;em&gt;Instruction Register&lt;/em&gt; (IR) holds the actual instruction while its being worked on.&lt;/p&gt;

&lt;p&gt;There are also a set of registers called &lt;em&gt;General Purpose Registers&lt;/em&gt; (GPR*). These don’t have a very specific purpose, they are left open for the programmer to use as they see fit while writing programs.&lt;/p&gt;

&lt;p&gt;Depending on how the IO devices are designed, there may be some dedicated registers attached to physical, user-interaction input or output devices.&lt;/p&gt;

&lt;h4 id=&quot;system-bus&quot;&gt;System Bus&lt;/h4&gt;

&lt;p&gt;As introduced with the tri-state buffer, we know that we can connect multiple digital outputs “together” forming a Bus topology. Von Neumann introduced the idea of a System Bus, where registers (and other components) read and wrote data to a central set of wires. This made interconnects easier, and made checking system functionality more straightforward. Modern processors may use more than one system bus to allow for faster data transfer, but for our purposes we will only consider one.&lt;/p&gt;

&lt;h4 id=&quot;the-execution-cycle&quot;&gt;The Execution Cycle&lt;/h4&gt;

&lt;p&gt;Most control units follow a repeating three-step process while running:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Fetch&lt;/li&gt;
  &lt;li&gt;Decode&lt;/li&gt;
  &lt;li&gt;Execute.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;/assets/controlUnitFetch.png&quot; alt=&quot;Control Unit Fetch&quot; /&gt;&lt;/p&gt;

&lt;p&gt;During the &lt;em&gt;Fetch&lt;/em&gt; phase, the control unit fetches the next instruction. The Program Counter register is used to populate the Memory Address Register. Then a read is commanded from the RAM chip, and the result in the Memory Data Register is moved to the Instruction Register.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/controlUnitDecode.png&quot; alt=&quot;Control Unit Decode&quot; /&gt;&lt;/p&gt;

&lt;p&gt;During the &lt;em&gt;Decode&lt;/em&gt; phase, the contents of the instruction are analyzed to see what is commanded. Control signals to other parts of the processor are adjusted based on the contents of the instruction.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/controlUnitMath.png&quot; alt=&quot;Control Unit Execute - Math&quot; /&gt;&lt;/p&gt;

&lt;p&gt;During the &lt;em&gt;Execute&lt;/em&gt; phase, the actual requested actions are carried out. The Program Counter is updated to a new value (usually the next memory address in sequence). The drawing above shows an example where the ALU is used to do math.&lt;/p&gt;

&lt;h4 id=&quot;decoding--executing-an-instruction&quot;&gt;Decoding &amp;amp; Executing an Instruction&lt;/h4&gt;

&lt;p&gt;Generally, instructions will command manipulations to registers. Some examples of these:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Math - Add two general purpose registers, and store the result in a 3rd general purpose register&lt;/li&gt;
  &lt;li&gt;Memory - Load a general purpose register from RAM, or store its contents to RAM&lt;/li&gt;
  &lt;li&gt;“Branching” - Manually adjust the Program Counter if the previous instruction’s result was positive&lt;/li&gt;
  &lt;li&gt;IO - reading/writing from some input or output device.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Instructions will always have two main components: the &lt;em&gt;opcode&lt;/em&gt; and the &lt;em&gt;arguments&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Remember that each instruction is just a set of bits. Usually, the first couple bits is the &lt;em&gt;opcode&lt;/em&gt;, which identify what the instruction is requesting.&lt;/p&gt;

&lt;p&gt;The exact mapping of &lt;em&gt;which&lt;/em&gt; bits equate to &lt;em&gt;which&lt;/em&gt; operations is dependant on the details of the processor construction. &lt;a href=&quot;http://ref.x86asm.net/coder32.html&quot;&gt;Here’s an example from x86&lt;/a&gt;, which is by far one of the more complex versions.&lt;/p&gt;

&lt;p&gt;Simpler machines might have a mapping more like:&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;opcode&lt;/th&gt;
      &lt;th&gt; &lt;/th&gt;
      &lt;th&gt;Abrev.&lt;/th&gt;
      &lt;th&gt;Meaning&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;0001&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;Add&lt;/td&gt;
      &lt;td&gt;Add two numbers&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;0010&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;Sub&lt;/td&gt;
      &lt;td&gt;Subtract two numbers&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;0011&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;OR&lt;/td&gt;
      &lt;td&gt;Bitwise OR of two numbers&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;0100&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;AND&lt;/td&gt;
      &lt;td&gt;Bitwise AND of two numbers&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;0101&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;NOT&lt;/td&gt;
      &lt;td&gt;Bitwise NOT of a numbers&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;0111&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;STR&lt;/td&gt;
      &lt;td&gt;Store a value to memory&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;1000&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;LD&lt;/td&gt;
      &lt;td&gt;Load a value from memory&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;1001&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;BRN&lt;/td&gt;
      &lt;td&gt;Branch to a different instruction if the previous result was negative&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;1010&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;BRZ&lt;/td&gt;
      &lt;td&gt;Branch to a different instruction if the previous result was zero&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;And so on. Note that when you see assembly instructions, you’ll almost always see it referred to by its abbreviation, not by the 1’s and 0’s of the opcode. It’s hard to stare at the 1’s a 0’s, your eyes start to go crossed after a while.&lt;/p&gt;

&lt;p&gt;The remaining bits are dedicated to the arguments to the opcode. They indicate the specifics of how the processor is to carry out the instruction.&lt;/p&gt;

&lt;p&gt;For instructions like Add, Subtract, AND, OR, etc. - the simplest set of arguments indicates a trio of general purpose registers to work with. Usually the arguments will be specified to say “source 1 register”, “source 2 register”, and “result register”. NOT would only need two registers, but is conceptually the same. When the Instruction Register has AND for an opcode, the control unit will use the arguments to configure the signal routing in the processor to pipe the two source register outputs into the ALU, and then the ALU’s output into the result register. One tick of the system clock goes by, the result register is updated, and the instruction is completed!&lt;/p&gt;

&lt;p&gt;Opcodes that work with memory addresses (BRN/BRZ,LD/STR) will often make one of the arguments the memory address to work with. More complex “addressing modes” allow the address to be specified relative to the program counter, or some general purpose register.&lt;/p&gt;

&lt;h4 id=&quot;choosing-the-next-instruction&quot;&gt;Choosing the Next Instruction&lt;/h4&gt;

&lt;p&gt;Generally, after all decoding and execution has been completed, the Program Counter has to be updated with the next address. Frequently, this just means “add one” to the current program counter. However, the instruction might have some more complex instruction. “Branch” instructions generally alter the add-one behavior conditionally, based on the previous result being positive, zero, or negative (PZN register stores this information every instruction cycle).&lt;/p&gt;

&lt;p&gt;The manner in which they alter it can vary far and wide. Usually it involves some offset from the current PC - rather than going to the next instruction, you skip forward by some larger number of addresses, or maybe backward by five addresses… something like that. The size of the jump may be encoded into the instruction word itself, or pulled from a general purpose register, or lots of other options really. At the end of the day, it’s just up to how the instruction is interpreted again to select which calculation is used to update the PC prior to the next execution cycle.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/nextInstructionDecode.png&quot; alt=&quot;next instruction&quot; /&gt;&lt;/p&gt;

&lt;p&gt;The net result is the same though - the PC gets loaded with the address of the next instruction to run, and the cycle may start over!&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/controlUnitNextInstruction.png&quot; alt=&quot;next instruction calc&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;io-techniques&quot;&gt;IO techniques&lt;/h3&gt;

&lt;p&gt;In general, any input and output device will have to interact with the processor via some set of bits. For example, a mouse might report its X/Y coordinates as two integers. A screen might require representing every pixel color with one byte of data. Regardless of how it’s actually done, just keep in mind that at the end of the day, it’s just a set of bits that are read from, or go to, the device.&lt;/p&gt;

&lt;p&gt;How the processor gets access to these bits happens through two primary methods:&lt;/p&gt;

&lt;h4 id=&quot;port-mapped&quot;&gt;Port Mapped&lt;/h4&gt;

&lt;p&gt;Some processors will have dedicated registers inside the control unit for reading and writing data associated with a user IO device. This also means there will have to be dedicated assembly instructions for manipulating that data as part of a program. THis is a very fast method, but can be a bit inflexible, as the processor has to be designed with assumptions about what its IO devices will be. This is bad if you plug or unplug a device from your computer.&lt;/p&gt;

&lt;h4 id=&quot;memory-mapped&quot;&gt;Memory Mapped&lt;/h4&gt;

&lt;p&gt;Sometimes, a more flexible technique is to use the same interface the RAM circuitry uses. The IO device “poses” as part of the RAM chip, responding to processor read and write requests just as a RAM chip would. But, rather than storing and recalling data as requested by a processor, the “other end” of each byte is hooked up to some IO device.&lt;/p&gt;

&lt;p&gt;This means there are no special assembly instructions required to do IO interaction. As a software writer, you just have to know things like “Memory addresses 0x0000154A and 0x0000154B are mouse X/Y” and “Memory addresses 0x00002000 through 0x00002FFF control the pixels on the screen”. Don’t use these special memory addresses like normal memory (ie, writing to the mouse addresses will probably not end well). But, it’s much more flexible than forcing a Port Mapped architecture.&lt;/p&gt;

&lt;p&gt;But, there are plenty of tradeoffs on both sides. You’ll probably see both as you adventure into this wonderful world of processors!&lt;/p&gt;

&lt;h2 id=&quot;concrete-examples-of-architecture&quot;&gt;Concrete Examples of Architecture&lt;/h2&gt;

&lt;p&gt;So far, we’ve stuck to generic descriptions of the common things you find inside a processor. Lots of descriptions have just been these hand-wavey “well the actual implementation depends on the processor type”. For the curious, we now present three concrete examples of computer architecure.&lt;/p&gt;

&lt;h3 id=&quot;lc-3&quot;&gt;LC-3&lt;/h3&gt;

&lt;p&gt;The “LC-3”, or “Little Computer 3”, is a “fake” architecture. You’ll not find an off-the-shelf chip that implements the “LC-3” architecture. But, it’s a dirt simple architecture - fixed opcode and word widths, simple operations, conveniently sized RAM… the list goes on.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://lumetta.web.engr.illinois.edu/120-F16/slide-copies/100-the-lc-3-isa.pdf&quot;&gt;There are a good number&lt;/a&gt; &lt;a href=&quot;https://www.cs.utexas.edu/users/fussell/courses/cs310h/lectures/Lecture_10-310h.pdf&quot;&gt;of online resources&lt;/a&gt; &lt;a href=&quot;http://www.ncsa.illinois.edu/People/kindr/teaching/ece190_sp11/lectures/lecture_11.pdf&quot;&gt;that explain the architecture&lt;/a&gt; - some even down to the gate level. It’s simple enough that the blog author implemented the processor, gate level up, as part of a sophomore year elective class.&lt;sup id=&quot;fnref:1&quot;&gt;&lt;a href=&quot;#fn:1&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;

&lt;p&gt;It’s a great place to start, but unfortunately doesn’t directly map to any real architecture. However, the concepts you learn while studying it definitely do apply!&lt;/p&gt;

&lt;h3 id=&quot;x86&quot;&gt;x86&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/X86&quot;&gt;x86 Processor Architecture&lt;/a&gt; comes from Intel, and dates back to the late 1970’s. Over the years they have added lots and lots of new instructions to it, expanded the data width size, and a whole slew of other alterations, all while keeping the base thing backward compatible. This makes for a &lt;em&gt;very&lt;/em&gt; versatile and &lt;em&gt;very&lt;/em&gt; powerful processor. The biggest downsides are all rooted in the complexity of the devices - infinite backward compatibility makes for a lot of “legacy” portions of the architecture that aren’t relevant for modern programming. Additionally, you need a &lt;em&gt;lot&lt;/em&gt; of gates to make an x86 processor, which generally means they are power hungry (though this has been mitigated in recent years).&lt;/p&gt;

&lt;p&gt;Still, the sheer flexibility and power of the architecture means almost every desktop PC (running Windows, Mac, or Linux) has some form of an x86 processor in it, and tons of manufacturers produce a flavor of the architecture.&lt;/p&gt;

&lt;p&gt;This was the second assembly language the author learned. Along with three other students, he wrote an operating system from scratch using C and x86 assembly. &lt;sup id=&quot;fnref:2&quot;&gt;&lt;a href=&quot;#fn:2&quot; class=&quot;footnote&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;

&lt;h3 id=&quot;arm&quot;&gt;ARM&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/ARM_architecture&quot;&gt;Advanced RISC Machine&lt;/a&gt; architecture is the new “big kid” on the block. Specifically designed to address some of the x86 shortcomings, it quickly made a name for itself for its simplicity of implementation (therefor requiring fewer transistors, and drawing less power). It came along at just the right time to be adopted by the smartphone revolution, and nearly all smartphones on the market today run some form of this processor. It’s strongly suited toward running mobile, power-sensitive applications. The roboRIO uses an ARM Cortex-A9 processor manufactured by Xilinx.&lt;/p&gt;

&lt;h3 id=&quot;the-place-of-the-special-purpose-computing-device&quot;&gt;The Place of the Special-Purpose Computing Device&lt;/h3&gt;

&lt;p&gt;This whole blog post, we’ve been discussing how to made a digital device which can perform general purpose computation. This isn’t to say that general purpose computers are the be-all, end-all of computation. Indeed, the ability to be programmed brings overhead with it. In the fetch/decode/execute cycle, fetch and decode are both only present because the processor has to figure out &lt;em&gt;what&lt;/em&gt; it is supposed to be doing at runtime, in addition to actually doing it.&lt;/p&gt;

&lt;p&gt;For this reason, when bleeding edge speed or absolutely minimal power consumption is required, it &lt;em&gt;sometimes&lt;/em&gt; still makes sense to give up the ability to be programmed to gain that speed or efficiency. Digital Devices can still be custom designed to fit a very specific purpose. These are often called &lt;em&gt;Application Specific Integrated Circuits&lt;/em&gt; (ASIC’s).&lt;/p&gt;

&lt;p&gt;Common applications include video/audio processing, computer networking devices, and scientific research equipment.&lt;/p&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;Phew, that was a lot, and way more hand-wavey than I had initially intended. None the less, we still have built up an understanding of what the main components of a processor are, how those things come to be from smaller digital circuits, and how they can execute individual stored instructions.&lt;/p&gt;

&lt;p&gt;Next up, we’ll take a survey of common programming language constructs, and later dig into how those constructs might be implemented in assembly code. Keep reading at &lt;a href=&quot;/blog_posts/2019/07/28/programming_language_intro.html&quot;&gt;Programming Languages Introduction!&lt;/a&gt;.&lt;/p&gt;

&lt;div class=&quot;footnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:1&quot;&gt;
      &lt;p&gt;Lots of students &lt;a href=&quot;https://www.google.com/search?safe=active&amp;amp;rlz=1C1CHBF_enUS840US840&amp;amp;ei=JIUuXcOzF8m4tAbC4bv4Cw&amp;amp;q=uiuc+ece+385+github&amp;amp;oq=uiuc+ece+385+github&amp;amp;gs_l=psy-ab.3..0i22i30.3858.5509..6305...0.0..0.107.585.6j1......0....1..gws-wiz.......0i71j0.a87FJGr1gW8&quot;&gt;post their solutions on github&lt;/a&gt;, which seems like a violation of academic integrity, if you ask me. &lt;a href=&quot;#fnref:1&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:2&quot;&gt;
      &lt;p&gt;Again, lots of students &lt;a href=&quot;https://www.google.com/search?q=uiuc+ece+391+github&amp;amp;rlz=1C1CHBF_enUS840US840&amp;amp;oq=uiuc+ece+391+github&amp;amp;aqs=chrome..69i57.5400j0j7&amp;amp;sourceid=chrome&amp;amp;ie=UTF-8&quot;&gt;decided to post their solutions online&lt;/a&gt;. Tisk tisk. &lt;a href=&quot;#fnref:2&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;</content><author><name></name></author><summary type="html">People who are more than casually interested in computers should have at least some idea of what the underlying hardware is like. Otherwise the programs they write will be pretty weird. - Donald Knuth</summary></entry><entry><title type="html">Processor Architecture Primer</title><link href="/blog_posts/2019/07/22/processor_arch_primer.html" rel="alternate" type="text/html" title="Processor Architecture Primer" /><published>2019-07-22T09:30:00-05:00</published><updated>2019-07-22T09:30:00-05:00</updated><id>/blog_posts/2019/07/22/processor_arch_primer</id><content type="html" xml:base="/blog_posts/2019/07/22/processor_arch_primer.html">&lt;h2 id=&quot;introduction&quot;&gt;Introduction&lt;/h2&gt;

&lt;p&gt;We’re on the verge of being able to describe all the main components of real processors! Huzzah, we are well on our way to getting real software up and running! Get excited!&lt;/p&gt;

&lt;p&gt;As one final preparation step, we want to do two things - set the historical scene for &lt;em&gt;what problem&lt;/em&gt; the design of the first processors was solving. We also want to explore a less-common but very-useful digital device called a “tri-state” buffer that will be key to our processor design function.&lt;/p&gt;

&lt;h2 id=&quot;some-history&quot;&gt;Some History&lt;/h2&gt;

&lt;p&gt;Way back in the day, if you had a lot of math to do, you would hire a &lt;a href=&quot;https://en.wikipedia.org/wiki/Human_computer&quot;&gt;human computer&lt;/a&gt; - literally, a person whose job it was to do computations. You gave them a set of instructions as to what math to do, and they came back with a set of numbers. Not a glamorous job, but it did pay the bills. If you had big calculations to do, you’d hire lots of them and find ways to divide the work. If you wanted to ensure accuracy, you’d hire twice as many as needed and have them both independently solve the same problem (and check the results).&lt;/p&gt;

&lt;p&gt;Obviously, there are some big limitations to this system. Humans make mistakes, grueling hours of arithmetic isn’t exactly the most fun way to spend your work day, and there’s only so fast that a human can do math. You can’t take a big problem and subdivide it efficiently between a million people, as the complexity of re-combining the results starts to outweigh the benefits of doing work in parallel. Due to these limitations, and the ever-increasing scope of work, there was a need to expand the computing capability of the scientific community in general.&lt;/p&gt;

&lt;p&gt;Toward the end of World War I and into World War II, there was an expanding notion of using machines to do rapid computation. The proximity to war-time meant a lot of the computation applications were, well, war-driven. &lt;a href=&quot;https://en.wikipedia.org/wiki/Enigma_machine&quot;&gt;Cryptography&lt;/a&gt;, &lt;a href=&quot;https://en.wikipedia.org/wiki/Bomba_(cryptography)&quot;&gt;attempting to break cryptography&lt;/a&gt;, calculating artillery trajectories, analyzing the feasibility of an atomic bomb…. Some simply calculated differential equations, but again the majority of the funding was pushed toward war-time effort.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/wwII.png&quot; alt=&quot;My mother is proud of my artwork.&quot; /&gt;&lt;/p&gt;

&lt;p&gt;These machines were quite large. Remember that the transistor had not yet been invented. The logic gates we have studied were conceptually still in use, but to implement them engineers had to use vacuum tubes or electro-mechanical switches. Additionally, the first machines were effectively hard-coded to do one single job. The government would come in and say “Johnson! We need a machine to help shoot shells at the enemy better! Here’s the equations, figure it out!” And then Johnson would go wire up one machine to do the job, and come back with an answer, and then the machine would be useless. Well, not entirely useless. But still, to do a different job (or even just tweak the equations), you had to spend lots of time re-designing parts of the circuitry, have technicians come in and physically re-wire the thing, test it all out, and hope you didn’t make any mistakes in the process.&lt;/p&gt;

&lt;p&gt;Given the need for speed in reprogramming, a group of engineers set out to design a machine which was much more easily reprogrammable. The quest was for a “general purpose” computer, which could do arbitrary computations as needed, and did not take a team of technicians to re-wire every time computational problem changed.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://upload.wikimedia.org/wikipedia/commons/8/8c/Two_women_operating_ENIAC_%28full_resolution%29.jpg&quot; alt=&quot;Eniac programming&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Alan_Turing&quot;&gt;Alan Turing&lt;/a&gt; provided a key portion of the theoretical background for the general purpose computer. The &lt;a href=&quot;https://en.wikipedia.org/wiki/Turing_machine&quot;&gt;“Turing Machine”&lt;/a&gt; is a formal mathematical description of what sorts of devices can perform general computation. His papers show both what sorts of problems are “computable” (ie solved with an algorithm, acting only with numbers, math, and logic), and what criteria a machine must have to solve an arbitrary problem. This ability to solve an arbitrary problem is what makes a computer “general-purpose”.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/turing_machine.png&quot; alt=&quot;Turing Machine&quot; /&gt;&lt;/p&gt;

&lt;p&gt;The classic demonstration of a simple Turing Machine involves a very large piece of magnetic tape, and a &lt;em&gt;Head&lt;/em&gt; - a device capable of moving along the tape, with the ability to read and write information from defined locations on the tape. The simple implementation is still problem specific - the instructions for how it reads, writes, and moves are hard-coded into the specific Turing Machine. Turing himself showed the possibility of a &lt;a href=&quot;https://en.wikipedia.org/wiki/Universal_Turing_machine&quot;&gt;“Universal Turing Machine”&lt;/a&gt;, which has a single programmed behavior to read the actual instructions from the tape itself. Therefor, the machine did not have to be changed, only the instructions stored in the tape. This is the basis of the “stored program” concept.&lt;/p&gt;

&lt;p&gt;As-described, the actual Turing Machine is &lt;a href=&quot;https://www.youtube.com/watch?v=FTSAiF9AHN4&quot;&gt;not particularly practical to build&lt;/a&gt;. It presumes a mechanical analogy, which fundamentally limits speed and size. Still, the theoretical background was required to provide the constraints on &lt;em&gt;how&lt;/em&gt; to hook up an electronic circuit such that the end result would ultimately solve the problem. Turing effectively provided the input constraints, and pass-fail criteria for the stored-program, general-purpose computer.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/John_von_Neumann&quot;&gt;John Von Neumann&lt;/a&gt; was another other major player in the early development of these stored-program computers. He is usually credited for leading the charge of transforming Turing’s theoretical work into a practical implementation of a general-purpose computer. He was highly involved in the design and development of &lt;a href=&quot;https://en.wikipedia.org/wiki/EDVAC&quot;&gt;EDVAC&lt;/a&gt; and later &lt;a href=&quot;https://en.wikipedia.org/wiki/ENIAC&quot;&gt;ENIAC&lt;/a&gt;, two of the first useful stored-program machines. The design we are about to study is the design he is largely credited for inventing.&lt;/p&gt;

&lt;p&gt;As a side note, both Turing and Von Neumann were crazy smart people, with scientific contributions well beyond the processor architecture we are studying.. Given all they did, its almost a disservice to think of them as the founders of the modern computer, as their influence in the scientific community was much broader.&lt;/p&gt;

&lt;h3 id=&quot;stored-program&quot;&gt;Stored Program&lt;/h3&gt;

&lt;p&gt;The “stored program” is really the key to unlocking programming efficiency and making computers general-purpose. A stored program is exactly what it sounds like. The program, or set of instructions for operation, is stored in a memory bank somewhere.&lt;/p&gt;

&lt;p&gt;This memory bank has to be purpose-designed to be easily manipulated. Data must be stored and retrieved at will, usually without direct human intervention (ie, no technician coming by to move wires).&lt;/p&gt;

&lt;p&gt;A stored program machine has to have the ability to know where these instructions are at, read them, determine their meaning, and carry out that meaning. This adds a bit of complexity to the machine, but it’s a one-time effort to add the complexity. It’s also a bit slower - any stored program machine has to spend at least some of its time just determining what the next instruction is, rather than carrying out “useful” computations. Finally, stored-program will always be less optimized. Since it’s not always possible to know exactly what the next set of instructions will be, it takes away some opportunities to optimize the speed &amp;amp; resource utilization of the algorithm.&lt;/p&gt;

&lt;p&gt;For this reason, there are still many special-purpose computers out there - high speed network interfaces and graphics cards are two common examples. The need for speed outstrips the need for flexibility.&lt;/p&gt;

&lt;p&gt;Still though, the stored-program, general purpose machine is the de-facto standard. Despite the potential limitations, it’s still much better than the alternatives. Just remember how much effort it takes to wire your whole robot up. Now imagine software team had a bug, so the only way to fix it is to re-wire the whole thing. That wouldn’t be fun. Stored program is the way to go.&lt;/p&gt;

&lt;h2 id=&quot;tri-state-buffer&quot;&gt;Tri-State Buffer&lt;/h2&gt;

&lt;p&gt;Before we start digging into how Von Neumann specified digital components should interact with each other, we will want to cover one more digital device. Actually, it’s not &lt;em&gt;technically&lt;/em&gt; digital because sit has three states, but let’s not get too technical.&lt;/p&gt;

&lt;p&gt;The Tri-State buffer introduces a third state to our binary system &lt;sup id=&quot;fnref:1&quot;&gt;&lt;a href=&quot;#fn:1&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;: “Z”. Z stands for &lt;a href=&quot;https://en.wikipedia.org/wiki/High_impedance&quot;&gt;“High Impedance”&lt;/a&gt;, which (in this context) is an excessively formal way of saying “not plugged in”.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/triState.png&quot; alt=&quot;Tri state buffer symbol&quot; /&gt;&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;CTRL&lt;/th&gt;
      &lt;th&gt;In&lt;/th&gt;
      &lt;th&gt; &lt;/th&gt;
      &lt;th&gt;Out&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;Z&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;Z&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;The device has two inputs - one for data (In) and one for controlling the state of the output (CTRL). When CTRL is 1, the input is passed straight to the output without alteration - basically, a &lt;em&gt;wire&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;When CTRL is 0, the output is forced to the Z “High impedance” state, effectively “unplugging” input from output. Basically, a &lt;em&gt;broken wire&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;The usefulness of such a device is that it enables us to physically connect multiple digital device outputs to the same physical wire, and select which one of them is &lt;em&gt;electrically connected&lt;/em&gt; to the wire. This selection ability means we can control which device dictates the binary 1/0 state of the bus.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/triStateUsageSimple.png&quot; alt=&quot;Tri state buffer Usage - C on the bus&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Here we see three digital devices with outputs linked. Since the buffer at the output of C has a control signal of 1, we know the final output will be the same as C. It can be said then that Digital Device C is controlling Output.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/triStateUsageSimple2.png&quot; alt=&quot;Tri state buffer Usage - A on the bus&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Similarly, we can setup A to control Output by turning off CTRL for C, and then turning on CTRL for A.&lt;/p&gt;

&lt;p&gt;When you have a setup like this:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;The wire downstream of all of the tri-state buffers is referred to as the “Bus”.&lt;/li&gt;
  &lt;li&gt;When the tri-state buffer is active, the device is said to &lt;em&gt;assert&lt;/em&gt; its output onto the bus.&lt;/li&gt;
  &lt;li&gt;When the tri-state buffer is active, the device is &lt;em&gt;active&lt;/em&gt; on the bus.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Obviously this is a 1-bit demonstration, but you can easily put 8, 32, or 64 of these together to make a bus that is one &lt;em&gt;word&lt;/em&gt; wide. The number of bits in a bus is its &lt;em&gt;width&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;As readers may have already noticed - only one device can assert its output onto the bus at the same time. If two devices attempt to assert onto the bus at the same time, and they assert different boolean values, you’ll find yourself with a short circuit and magic smoke in no time. For this reason, the devices have to be coordinated somehow to ensure only one is active on the bus at a time.&lt;/p&gt;

&lt;h3 id=&quot;the-system-data-bus&quot;&gt;The System Data Bus&lt;/h3&gt;

&lt;p&gt;System Data bus is a common set of wires that transfers data from one device to another. A quick taste of what’s to come: at the core of the Von Neumann architecture is a data bus that is used by all components to transfer data back and forth. Each device has a set of tri-state buffers on its output so it can selectively take control of the bus, or allow some other device to assert its data. Additionally, each device has some ability to read the value from the bus, and pull it internally (to do something useful with it, presumably?).&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/systemBusBasic.png&quot; alt=&quot;Basic system bus concept&quot; /&gt;&lt;/p&gt;

&lt;p&gt;In this case we’ve chosen to draw a 32-bit wide bus (like most processors up till a few years ago had).&lt;/p&gt;

&lt;h2 id=&quot;register-load-and-store&quot;&gt;Register Load and Store&lt;/h2&gt;

&lt;p&gt;From previous, we know how to “gang” multiple D flip flops together to make what we call a “register”, which can store one &lt;em&gt;word&lt;/em&gt;’s worth of bits.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/register.png&quot; alt=&quot;4 bit register&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Since we started with a 32-bit bus, let’s also keep 32 bits here.&lt;/p&gt;

&lt;p&gt;Along with the system bus, imagine if each device is a slightly modified register. We’ll go ahead and use the little circuit created as part of an alarm clock to put a mux on the input to the register. We’ll also add our tri-state buffer output.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/registerWithWriteEnable.png&quot; alt=&quot;useful Von Neumann architecture register&quot; /&gt;&lt;/p&gt;

&lt;p&gt;We have the addition of the “Write Enable” enable input to choose whether the register is to load a new value from the data input or preserve its previous value. The “Output Enable” signal allows us to choose whether the output is active or not, allowing this register to be placed as a device on a system data bus with other registers.&lt;/p&gt;

&lt;p&gt;We can draw the following symbol for an abstraction of this device:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/32bitRegister.png&quot; alt=&quot;32 bit register&quot; /&gt;&lt;/p&gt;

&lt;p&gt;These registers will make up the core of data storage on the processor, and will be a key component going forward.&lt;/p&gt;

&lt;p&gt;To demonstrate how they are used, take as an example 3 registers sharing a 32-bit data bus:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/registersOnABus.png&quot; alt=&quot;registers on a bus&quot; /&gt;&lt;/p&gt;

&lt;p&gt;We now have a system where we can systematically transfer data from one register to another. We have to have something coordinating the write &amp;amp; output enables for all of the registers together - however, assuming you do, it’s actually quite easy to move data around now.&lt;/p&gt;

&lt;p&gt;Say you have a number in register A that you want to move to register C. Before the clock has a rising edge, you simply set register A’s &lt;em&gt;Output Enable&lt;/em&gt; to 1, and register C’s &lt;em&gt;Write Enable&lt;/em&gt; to 1 (and everything else to 0). Then, on the rising edge of the clock, the value from A will end up in register C, while B remains unchanged.&lt;/p&gt;

&lt;p&gt;We will notate this sort of transfer with a shorthand description:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;A \rightarrow C&lt;/script&gt;

&lt;p&gt;This simply indicates that on this particular clock cycle, we transfer the value from A into C.&lt;/p&gt;

&lt;p&gt;This is often called “Register Transfer Language”, and is the basis of the way we’ll describe how data gets transferred around in a processor. The key to remember is that behind every description of &lt;script type=&quot;math/tex&quot;&gt;A \rightarrow C&lt;/script&gt; or &lt;script type=&quot;math/tex&quot;&gt;B \rightarrow A&lt;/script&gt;, it’s just a set of enable bits getting set correctly, such that data flows from from the source to the destination.&lt;/p&gt;

&lt;h2 id=&quot;next-steps---where-are-we-going&quot;&gt;Next Steps - Where are we going?&lt;/h2&gt;

&lt;p&gt;That’s enough history and context-less introduction. Please promptly check out &lt;a href=&quot;/blog_posts/2019/07/22/vonneumann.html&quot;&gt;Von Neumann Processor Architecture&lt;/a&gt;!&lt;/p&gt;

&lt;div class=&quot;footnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:1&quot;&gt;
      &lt;p&gt;For the curious, formal systems of modeling the state of analog electronics in a “digital-useful” way can &lt;a href=&quot;https://en.wikipedia.org/wiki/Logic_level&quot;&gt;go up to having 9 states&lt;/a&gt;. &lt;a href=&quot;#fnref:1&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;</content><author><name></name></author><summary type="html">Introduction</summary></entry><entry><title type="html">Digital Devices Part Two - Sequential Logic</title><link href="/blog_posts/2019/07/06/digital_devices_part2.html" rel="alternate" type="text/html" title="Digital Devices Part Two - Sequential Logic" /><published>2019-07-06T09:30:00-05:00</published><updated>2019-07-06T09:30:00-05:00</updated><id>/blog_posts/2019/07/06/digital_devices_part2</id><content type="html" xml:base="/blog_posts/2019/07/06/digital_devices_part2.html">&lt;p&gt;This post is the continuation of &lt;a href=&quot;/blog_posts/2019/06/26/digital_devices.html&quot;&gt;Part 1&lt;/a&gt; in our series on digital devices.&lt;/p&gt;

&lt;h2 id=&quot;combinational-versus-sequential-logic&quot;&gt;Combinational versus Sequential Logic&lt;/h2&gt;

&lt;p&gt;So far, we have discussed circuits which take a set of inputs, and produce an output. They do not “remember” any particular piece of information - their outputs are a function current inputs only. They keep no record of past inputs. These are called &lt;em&gt;Combinational Logic&lt;/em&gt; circuits.&lt;/p&gt;

&lt;p&gt;As we mentioned earlier in the case of the astronaut button, sometimes it is useful to remember information about past information. Circuitry which accomplishes this memory is called &lt;em&gt;Sequential Logic&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;All the logic gates we’ve shown so far are by themselves combinational devices. However, we’ll now introduce a class of devices where outputs are &lt;em&gt;carefully&lt;/em&gt; fed back into inputs, allowing the device to retain information over time. We will be able to build these up into a full RAM chip, just like you have on your computer to store information!&lt;/p&gt;

&lt;h2 id=&quot;flip-flop&quot;&gt;Flip Flop&lt;/h2&gt;

&lt;p&gt;The most fundamental unit of memory storage is usually referred to as a &lt;a href=&quot;https://en.wikipedia.org/wiki/Flip-flop_(electronics)&quot;&gt;&lt;em&gt;flip flop&lt;/em&gt;&lt;/a&gt;. Much like the beach-oriented footwear, they flip and flop back and forth between true and false, with transitions triggered by certain input conditions. They also come in a number of different flavors. The easiest to analyze at first is often called the “SR Latch”, which we’ll look into as an example. Then we’ll abstract away the details and talk about a few other varieties.&lt;/p&gt;

&lt;h3 id=&quot;gate-propagation-delay&quot;&gt;Gate Propagation Delay&lt;/h3&gt;

&lt;p&gt;One thing we haven’t touched on yet - how long does it take a gate to do a calculation? So far we’ve kinda just ignored it - effectively assumed the answer is “infinitely fast”. Of course, nothing is infinitely fast. Voltages can’t change instantaneously, electrons take time to move around! When you apply a certain input combination to a gate, the reaction is quite quick - usually on the order of &lt;em&gt;nanoseconds&lt;/em&gt;. However, it’s not literally instantaneous. &lt;a href=&quot;https://en.wikipedia.org/wiki/Propagation_delay&quot;&gt;&lt;em&gt;Propagation delay&lt;/em&gt;&lt;/a&gt; is the name given to this duration between applying inputs, and seeing the correct output.&lt;/p&gt;

&lt;p&gt;This is yet another example of abstraction. For combinational logic, we are able to ignore this gate delay - assuming it is faster than anything we would ever care about (ie &lt;em&gt;instantaneous&lt;/em&gt;). For sequential logic, understanding the function of our new flip-flop friends requires we at least keep this delay in mind.&lt;/p&gt;

&lt;h3 id=&quot;basic-flip-flop-ideas&quot;&gt;Basic Flip Flop Ideas&lt;/h3&gt;

&lt;p&gt;The key to any flip-flop - we take the output, and route it back to an input. Due to gate delay, this effectively makes the “previous output” an input. When the previous output is an input, we can use it to remember what the output &lt;em&gt;used&lt;/em&gt; to be. With some clever design, we can in fact make some useful memory happen.&lt;/p&gt;

&lt;p&gt;The SR Latch consists of two &lt;em&gt;cross-coupled&lt;/em&gt; NAND gates, hooked up like this:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://upload.wikimedia.org/wikipedia/commons/c/c6/R-S_mk2.gif&quot; alt=&quot;SR Latch&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Wikipedia has the best picture of this I’ve seen so far, so I use theirs.&lt;/p&gt;

&lt;p&gt;The &lt;script type=&quot;math/tex&quot;&gt;S&lt;/script&gt; input is for “Set”, and the &lt;script type=&quot;math/tex&quot;&gt;R&lt;/script&gt; input is for “Reset”. The output is named &lt;script type=&quot;math/tex&quot;&gt;Q&lt;/script&gt;. Note by the GIF:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;When you set &lt;script type=&quot;math/tex&quot;&gt;S&lt;/script&gt; to 1 and &lt;script type=&quot;math/tex&quot;&gt;R&lt;/script&gt; to 0, this will cause the &lt;script type=&quot;math/tex&quot;&gt;Q&lt;/script&gt; output to go to 1&lt;/li&gt;
  &lt;li&gt;When you set &lt;script type=&quot;math/tex&quot;&gt;S&lt;/script&gt; to 0 and &lt;script type=&quot;math/tex&quot;&gt;R&lt;/script&gt; to 1, this will cause the &lt;script type=&quot;math/tex&quot;&gt;Q&lt;/script&gt; output to go to 0&lt;/li&gt;
  &lt;li&gt;When you set both &lt;script type=&quot;math/tex&quot;&gt;R&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;S&lt;/script&gt; to 0, it causes &lt;script type=&quot;math/tex&quot;&gt;Q&lt;/script&gt; to maintain its value&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Number 3 is the magic of the device - by leaving both inputs at 0, your output retains its previous value. This illustrates how you can hook gates up in a way to remember something about the previous inputs.&lt;/p&gt;

&lt;p&gt;Note how the loop-back of outputs back into input only makes sense if you assume gate delays are present. There is a &lt;em&gt;very&lt;/em&gt; slight delay between a change in input and a change in output, as shown in the gif. If you assume things change instantaneously, you get logical conflicts and are setting 1 equal to 0 (which implies a short circuit, which usually means &lt;a href=&quot;https://en.wikipedia.org/wiki/Magic_smoke&quot;&gt;magic smoke&lt;/a&gt; is getting out ). But, due to gate delays, for carefully designed circuits this is not a problem. When you buy the real chips that have SR Latches in them, the silicon has been carefully designed to make the gate delays &lt;em&gt;just right&lt;/em&gt; so this all works out. And then you as the user don’t have to worry about it. Yay abstraction!&lt;/p&gt;

&lt;p&gt;The astute reader may notice that there is a key flaw &lt;sup id=&quot;fnref:1&quot;&gt;&lt;a href=&quot;#fn:1&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt; to this configuration: Look what happens if you set both inputs to 1. Starting near &lt;script type=&quot;math/tex&quot;&gt;R&lt;/script&gt; - &lt;script type=&quot;math/tex&quot;&gt;\overline{1 + Q} = \overline{Q}&lt;/script&gt;, meaning &lt;script type=&quot;math/tex&quot;&gt;Q&lt;/script&gt; is equal to &lt;script type=&quot;math/tex&quot;&gt;\overline{Q}&lt;/script&gt;. Wait a minute. True can’t be equal to False. Huh.&lt;/p&gt;

&lt;p&gt;In reality what happens here depends on how your gates are constructed with transistors (you have to go one layer down in the layers of abstraction). You might get oscillation, or maybe short circuits and magic smoke. Depends. No matter what, setting both inputs to 1 is a bad idea. Due to this, it’s common to put additional gates in front of the S and R inputs to facilitate ensuring you never get the latch into a wacky state.&lt;/p&gt;

&lt;h3 id=&quot;the-clock-signal&quot;&gt;The Clock Signal&lt;/h3&gt;

&lt;p&gt;To properly motivate the specific flavor of flip-flop that we will be talking about, we will first take a tangent into a bit of processor design.&lt;/p&gt;

&lt;p&gt;Think about when you read about specifications for a processor. One of the most common specs you read about is the processor’s speed, which is measured in some units of &lt;em&gt;Hertz&lt;/em&gt;. Modern desktop processors are rated to run at around 2 to 3 GHz (Giga-Hertz, or &lt;script type=&quot;math/tex&quot;&gt;10^{9}&lt;/script&gt; Cycles per Second). This speed rating roughly corresponds to the number of operations the processor can do per second. But what it &lt;em&gt;really&lt;/em&gt; references to is the &lt;em&gt;clock speed&lt;/em&gt; of the processor &lt;sup id=&quot;fnref:2&quot;&gt;&lt;a href=&quot;#fn:2&quot; class=&quot;footnote&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;.&lt;/p&gt;

&lt;p&gt;The &lt;a href=&quot;https://en.wikipedia.org/wiki/Clock_signal&quot;&gt;&lt;em&gt;clock&lt;/em&gt;&lt;/a&gt; in a digital circuit is just a specially-designated signal. The clock cycles repeatedly between 1 and 0 and 1 and 0 at some specific frequency. Digital devices are designed to take a clock signal as one of their inputs to help it to stay in synchronization with other devices in the system.&lt;/p&gt;

&lt;p&gt;Circuits are designed such that at every &lt;em&gt;edge&lt;/em&gt; of the clock, or every transition from 0 to 1 (or so we will assume for now), it is assumed that all inputs to a particular digital device are &lt;em&gt;stable&lt;/em&gt; and therefore &lt;em&gt;available&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;The maximum clock speed is dictated by the worst-case propagation delay from the circuits that make up the system. If you have constructed some circuit with 10 AND gates passing each output to the next one’s input - you have to wait 10 times the gate delay before you know that your output is stable. Assuming that output goes to another circuit’s input, and they share a clock, you can’t run your clock faster than each portion of the circuit can update the inputs of the next portion.&lt;/p&gt;

&lt;p&gt;This is why reducing the number of layers of gates is important - the fewer layers you have, the less input to output delay you have, and the faster you can run your digital circuit’s clock. This means faster computation, which is generally regarded as a good thing!&lt;sup id=&quot;fnref:3&quot;&gt;&lt;a href=&quot;#fn:3&quot; class=&quot;footnote&quot;&gt;3&lt;/a&gt;&lt;/sup&gt;.&lt;/p&gt;

&lt;h4 id=&quot;but-mommy-where-do-baby-clocks-come-from&quot;&gt;But Mommy, Where do Baby Clocks Come From?&lt;/h4&gt;

&lt;p&gt;Don’t worry child, we will tell you when you are older.&lt;/p&gt;

&lt;p&gt;Actually, it doesn’t matter too much for our design purposes. This is the beauty of abstraction - you don’t need to know &lt;em&gt;how&lt;/em&gt; a clock signal is generated to &lt;em&gt;use&lt;/em&gt; it. But for the curious, we will indulge you momentarily.&lt;/p&gt;

&lt;p&gt;A clock is just a repeating waveform, and can be derived from any repeating pattern in nature. Common ways of generating it include:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Getting it from the power line (usually a nice 60Hz in North America, unless your &lt;a href=&quot;https://en.wikipedia.org/wiki/Utility_frequency#Stability&quot;&gt;power company screws up&lt;/a&gt;.)&lt;/li&gt;
  &lt;li&gt;Repeatedly charging and discharging a capacitor through a resistor and a non-linear switching circuit (for example, see &lt;a href=&quot;https://en.wikipedia.org/wiki/555_timer_IC&quot;&gt;“555 timer” circuit design&lt;/a&gt;).&lt;/li&gt;
  &lt;li&gt;Amplifying the vibrations of a specially-designed &lt;a href=&quot;https://en.wikipedia.org/wiki/Crystal_oscillator&quot;&gt;crystal made of quartz.&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/NIST-F2&quot;&gt;Using lasers to toss caesium atoms in the air then measuring their atomic energy state decay&lt;/a&gt;.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://xkcd.com/730/&quot;&gt;A whole host of other things&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;In addition, there’s a whole science to distributing this clock signal carefully to all the circuit elements, so they actually receive nice clean 0-to-1 transitions at the same time. Especially when clock frequencies get high, those wires inside your processor start to act less like ideal wires, and &lt;a href=&quot;https://en.wikipedia.org/wiki/Transmission_line&quot;&gt;more like radio antennas&lt;/a&gt;. It gets mucky fast.&lt;/p&gt;

&lt;p&gt;We don’t like to think about all this at once. So we use our powers of &lt;em&gt;abstraction&lt;/em&gt; to simply say &lt;em&gt;we trust a clock signal exists and works well, now we will use it&lt;/em&gt;.&lt;/p&gt;

&lt;h3 id=&quot;the-d-flip-flop-from-gates&quot;&gt;The D flip-flop from Gates.&lt;/h3&gt;

&lt;p&gt;Here’s our design goal - we want to build a device where we can predictably control when the output changes based on some clock signal input. We will have a single input that dictates when the &lt;em&gt;next&lt;/em&gt; output will be, and when the clock input &lt;em&gt;changes&lt;/em&gt; from 0 to 1, we will update our output to match our input. At all other times, the output should retain its state.&lt;/p&gt;

&lt;p&gt;We do this by cascading multiple SR latches together, such that an input, or some feedback value, “drops through” each layer as the clock swings from 0 to 1. Neglecting gate propagation delay, the 0 to 1 &lt;em&gt;rising edge&lt;/em&gt; of the clock will be the event that ultimately causes a new input to appear at the output.&lt;/p&gt;

&lt;p&gt;I am again in debt to Wikipedia for providing some images of gate configurations. Far easier than drawing it myself, and equally correct.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://upload.wikimedia.org/wikipedia/commons/thumb/9/99/Edge_triggered_D_flip_flop.svg/1920px-Edge_triggered_D_flip_flop.svg.png&quot; alt=&quot;Edge Triggered D Flip Flop&quot; /&gt;&lt;/p&gt;

&lt;p&gt;It might be a bit hard to trace the functionality, but it’s actually pretty straightforward. When the input labeled &lt;em&gt;Clock&lt;/em&gt; goes from a 0 to a 1, the output &lt;script type=&quot;math/tex&quot;&gt;Q&lt;/script&gt; takes on whatever value is applied at the &lt;script type=&quot;math/tex&quot;&gt;D&lt;/script&gt; input. &lt;script type=&quot;math/tex&quot;&gt;\overline{Q}&lt;/script&gt; is of course always the inverse of &lt;script type=&quot;math/tex&quot;&gt;Q&lt;/script&gt;.&lt;/p&gt;

&lt;h3 id=&quot;abstraction&quot;&gt;Abstraction&lt;/h3&gt;

&lt;p&gt;When you draw out one of these devices in a circuit diagram, it’s actually confusing to do it with gates. Astute document readers might recognize “oh that’s a D flip flop!”. But in reality, you don’t want to make people think about that, you just want them to know it. So, there’s a fairly generic symbol that gets drawn:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://upload.wikimedia.org/wikipedia/commons/thumb/8/8c/D-Type_Flip-flop.svg/1920px-D-Type_Flip-flop.svg.png&quot; alt=&quot;D Flip Flop symbol from Wikipedia&quot; /&gt;&lt;/p&gt;

&lt;p&gt;The ports are labeled about as you’d expect from above. The little notched &lt;script type=&quot;math/tex&quot;&gt;&gt;&lt;/script&gt; indicates the clock input.&lt;/p&gt;

&lt;p&gt;The &lt;script type=&quot;math/tex&quot;&gt;S&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;R&lt;/script&gt; ports are often omitted from other drawings. They will force the output to 1 (&lt;script type=&quot;math/tex&quot;&gt;S&lt;/script&gt;) or 0 (&lt;script type=&quot;math/tex&quot;&gt;R&lt;/script&gt;) immediately, regardless of the value of the clock or &lt;script type=&quot;math/tex&quot;&gt;D&lt;/script&gt;. This is useful for a &lt;em&gt;reset&lt;/em&gt; circuit, which (when activated) puts all the devices into a known state. This is useful when first powering on (or rebooting) your computer - depending on the exact transistor layout, the state of each flip flop may not be guaranteed when you first apply power to the circuit. Some might be 1, some might be 0…who knows. To get around this, designers usually just build in the ability to force every piece of the circuit to a known state.&lt;/p&gt;

&lt;h3 id=&quot;but-why-a-clock&quot;&gt;But, Why a Clock?&lt;/h3&gt;

&lt;p&gt;The reason for triggering on the rising edge is for &lt;em&gt;synchronization&lt;/em&gt; across the larger system. Think about a computer chip - you’ll have many many many of these memory components spread throughout your processor, RAM, peripherals, device drivers, etc. You want to be sure that they all change state at the same time, so you design your circuit with a rising-edge paradigm in mind. Namely - when the clock is not having a rising edge, you have that whole time to do all the combinational logic. Signals propagate around, change gate state, do calculations and whatnot…. you can do whatever you like in this time, just as long as &lt;em&gt;all Flip Flop inputs&lt;/em&gt; and stable before the &lt;em&gt;next clock rising edge&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;For the sake of completeness, it should be noted that digital circuits are often &lt;em&gt;falling edge&lt;/em&gt; triggered. This changes the circuit design a bit, but the concept remains the same. It doesn’t matter if your clock goes “1 0 1 0…” or “0 1 0 1…”. General design principles would say to keep all your devices the same - all rising edge or all falling edge triggered. But even this can be violated if you’re careful enough. Not worth focusing on too much now, but just for awareness - rising-ege isn’t the only option.&lt;/p&gt;

&lt;h2 id=&quot;counter&quot;&gt;Counter&lt;/h2&gt;

&lt;p&gt;Let’s put together a circuit combining two things we have just learned about - adders and flip flops. Our goal will be to build a device which keeps track of time, counting the number of clock cycles. To keep things simple, we’re going to pretend that we’re building a clock for planet Zorgon. It’s a zippy but precise planet, revolving once around its axis once every 16 seconds exactly. Our Zorgon clock therefor just needs to count up from 0 to 15 to track all the seconds in the day, then reset back to 0 after the 15th second (when it is the next day).&lt;/p&gt;

&lt;p&gt;If you recall from the binary lesson, if we have 4 bits and treat them as an unsigned integer, we can exactly represent the numbers 0 through 15 (since &lt;script type=&quot;math/tex&quot;&gt;15 = (2^{4}-1&lt;/script&gt;)). They don’t call Zorgon the “Planet of Simplifying Mathematical Coincidences” for nothing!&lt;/p&gt;

&lt;p&gt;To store the present time, we will use 4 D flip flops in parallel. This is nothing fancy, just creating a new digital device with three main ports. A 4-bit input, with one bit going to the &lt;script type=&quot;math/tex&quot;&gt;D&lt;/script&gt; input each flip flop. The 4-bit output comes directly from the individual &lt;script type=&quot;math/tex&quot;&gt;Q&lt;/script&gt; bits at the output of each flip flop. The clock input is still one bit, and drives all flip flop clocks simultaneously. Effectively, we’ve created a flip flop that stores 4 bits at a time, rather than one. This device is often called a &lt;em&gt;register&lt;/em&gt;&lt;sup id=&quot;fnref:4&quot;&gt;&lt;a href=&quot;#fn:4&quot; class=&quot;footnote&quot;&gt;4&lt;/a&gt;&lt;/sup&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/register.png&quot; alt=&quot;4 bit register&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Rather than drawing all 4 gates every time, we’ll put all this in a nice little box labeled “Register”:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/4bitRegister.png&quot; alt=&quot;4 bit register abstraction symbol&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Note the little “/” marks on the input and output ports with the number &lt;script type=&quot;math/tex&quot;&gt;4&lt;/script&gt; below it. That’s just a notation way to say “here are four wires that should remain together”. You should always think of those four bits together as representing “time of day”, so we’ll draw them together to help not confuse the reader. Some programs may use a thicker line to show the “bundle” of data wires.&lt;/p&gt;

&lt;p&gt;We will make the assumption that we have a clock signal that already runs at 1 Hz (this is not hard to create). &lt;em&gt;Hz&lt;/em&gt; (abbreviation for “Hertz”) means “cycles per second”. Since each cycle of the clock waveform has exactly one rising edge and one falling edge, we expect once per second our (rising edge triggered) flip flops will propagate their input to the output.&lt;/p&gt;

&lt;p&gt;Here’s the key to the design: the &lt;em&gt;output&lt;/em&gt; of the register will be used to represent the &lt;em&gt;present&lt;/em&gt; time on Zorgon. Every rising edge of the clock, we will want to increase the present time by 1 (since, of course, time goes forward). To do this, we need to ensure that at all times, the input to the register is the current time, plus 1. This will ensure that when the clock has a rising edge, the new time (cur_time + 1) is propagated to the output, and the output (representing current time) updates properly.&lt;/p&gt;

&lt;p&gt;We’ll take a quick shortcut to represent our four bit adder from last time as one block:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/4bitAdder.png&quot; alt=&quot;4 bit adder abstraction symbol&quot; /&gt;&lt;/p&gt;

&lt;p&gt;“Inside the box” we’ve accounted for the fact that the carry-in signal is hardcoded to 0, and the carry out signal is unused and not connected.&lt;/p&gt;

&lt;p&gt;We’ll hook up a circuit like this:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/zorgonClock.png&quot; alt=&quot;Zorgon Clock&quot; /&gt;&lt;/p&gt;

&lt;p&gt;We see our 4-bit ripple carry adder, like we had &lt;a href=&quot;/blog_posts/2019/06/26/digital_devices.html&quot;&gt;last time&lt;/a&gt;. That “constant value” of 1 is achieved by simply connecting the 0th bit to a high voltage, and all the other bits to ground.&lt;/p&gt;

&lt;p&gt;There! With just a few components, we’re able to create a circuit that keeps track of the present time of (Zorgon) day, and outputs it in a binary format!&lt;/p&gt;

&lt;h3 id=&quot;a-zorgon-alarm-clock&quot;&gt;A Zorgon Alarm Clock&lt;/h3&gt;

&lt;p&gt;Knowing the current time of day is cool, but what if you want to be notified at a certain time every day? Say, for example, the time you want to wake up at! This is a device most folks would call an &lt;em&gt;alarm clock&lt;/em&gt;. As the english name suggests, we could start with our clock, and add an alarm circuit to it.&lt;/p&gt;

&lt;p&gt;The alarm circuit is simple. We shall define it as such: it takes two inputs: the current time of day, and the desired time of alarm. Current time comes from our existing clock circuit, and desired alarm time has to come as input from the user. If you want to be woken up by your alarm on the 4th second of the day, you would provide the input bits &lt;script type=&quot;math/tex&quot;&gt;0100_2&lt;/script&gt;. Providing user input in digital circuits like this is usually just done through switches that selectively tie digital signals to ground or 5V. Something like &lt;a href=&quot;https://www.jameco.com/z/78B04ST-Grayhill-DIP-Switch-On-Off-Single-Pole-Single-Throw-4-Raised-Slide-0-15-Amp-30-Volt-PC-Pins-2000-Cycle-2-5mm-Through-Hole-Tube_696950.html?%20CID=GOOG&amp;amp;gclid=Cj0KCQjwgezoBRDNARIsAGzEfe7hcHovtbSrxWYDnhEjBbvDTIrS4ydOLhCMUV2kU8dR8l9B52EvHOcaAtGKEALw_wcB&quot;&gt;this&lt;/a&gt; - you’ve possibly seen these in old garage door openers? Maybe? Or maybe I’m getting old.&lt;/p&gt;

&lt;p&gt;In any case, we will define that the output of our alarm circuitry is a single bit. It shall be 1 when the current time matches the alarm time, and 0 otherwise. We’ll assume it’s hooked up to some loud buzzer, or a motor that drives a 2x4 into your skull, or releases a flock of penguins, or something “alerting” of that nature. But through the power of abstraction, we will simply leave it at 1 = “alert” and 0 = “no alert”.&lt;/p&gt;

&lt;p&gt;To calculate the output, we need to calculate if the two inputs are &lt;em&gt;exactly&lt;/em&gt; equal. Doing this across four bits is quite trivial - for two four-bit numbers to be &lt;em&gt;exactly&lt;/em&gt; equal, it just means that every one of their bits is equal.&lt;/p&gt;

&lt;p&gt;Recall that the output of an XOR gate reports when two bits are different (1 for different, 0 for same). By putting an inverter on the output of an XOR gate, we’ve created an XNOR gate, which produces 1 when the bits are the same, but 0 when they are different.&lt;/p&gt;

&lt;p&gt;Similarly, a 4-input AND gate will output 1 when all 4 inputs are true, and 0 otherwise (1 or more inputs are 0).&lt;/p&gt;

&lt;p&gt;Combining these together in a circuit like this, we create a simple box which outputs a boolean to indicate “are my two 4-bit inputs exactly equal” &lt;sup id=&quot;fnref:4:1&quot;&gt;&lt;a href=&quot;#fn:4&quot; class=&quot;footnote&quot;&gt;4&lt;/a&gt;&lt;/sup&gt;:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/alarm_circuit.png&quot; alt=&quot;Alarm Comparison Circuit&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Here we’ve used names A and B for the 4-bit inputs (A consists of A_0, A_1, A_2, and A_3). A is the current time, B is the set time from the user (though order technically won’t matter).&lt;/p&gt;

&lt;p&gt;We’ll wrap this circuit up into a nice little box that compares two four-bit numbers for equality:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/compareEq.png&quot; alt=&quot;Compare Equality abstraction symbol&quot; /&gt;&lt;/p&gt;

&lt;p&gt;We can then hook this guy up to our existing clock circuit, and we suddenly can be woken up at the proper time on planet Zorgon!&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/zorgonAlarmClock.png&quot; alt=&quot;Zorgon Alarm Clock Circuit&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Huzzah!&lt;/p&gt;

&lt;h3 id=&quot;too-close-to-home&quot;&gt;Too close to home&lt;/h3&gt;

&lt;p&gt;“But But But!”, you say. “We live on planet Earth! A Zorgon clock is useless for day to day life!”. I hear you, and do not disagree. Let’s think through what we’d have to do to make this clock work on Earth (where there are &lt;script type=&quot;math/tex&quot;&gt;24 * 60 * 60 = 86400&lt;/script&gt; seconds in one day).&lt;/p&gt;

&lt;p&gt;For starters, we’ll need more bits. &lt;script type=&quot;math/tex&quot;&gt;log_{2}(86400) = 16.3984&lt;/script&gt;, so we’ll need at least 17 bits to represent the present “second of the day”. This should be easy enough - just expand both the register and the adder to have 17 bits, and re-connect wires.&lt;/p&gt;

&lt;p&gt;The second problem is that on Zorgon, the counter “rolled over” back to 0 at just the right time. This is because of the way binary addition works when you have a fixed set of output bits:&lt;/p&gt;

&lt;p&gt;&lt;script type=&quot;math/tex&quot;&gt;0001_{2} + 1111_{2} = 10000_{2}&lt;/script&gt; But because of how the ripple-carry adder is implemented, that top bit “drops off”, or is otherwise discarded. This leaves the result of the addition operation as &lt;script type=&quot;math/tex&quot;&gt;0000_{2} = 0_{10}&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;Earth is not nearly as nice. We have to manually reset the count back to zero on the start of each day. Let us create a “new-day-detection” circuit which uses that same comparison logic in the Alarm Clock to check whether the current second count is the last second of the day (second &lt;script type=&quot;math/tex&quot;&gt;86399_{10} = 10101000101111111_2&lt;/script&gt; ). When all 17 bits of the current time are exactly equal to the last second of the day, the logic outputs a 1.&lt;/p&gt;

&lt;h4 id=&quot;the-mux&quot;&gt;The MUX&lt;/h4&gt;

&lt;p&gt;There is another combinational logic device I’d like to quickly introduce you to - it’s called a &lt;em&gt;multiplexer&lt;/em&gt;, or &lt;em&gt;mux&lt;/em&gt; for short. It has a set of input signals, some &lt;em&gt;select lines&lt;/em&gt;, and a single output. Based on the value at the &lt;em&gt;select line&lt;/em&gt; inputs, the appropriate input is propagated to the output.&lt;/p&gt;

&lt;p&gt;From similar reasoning that we used above, the number of select lines required is equal to &lt;script type=&quot;math/tex&quot;&gt;\lceil log_{2}(N) \rceil&lt;/script&gt; where &lt;script type=&quot;math/tex&quot;&gt;N&lt;/script&gt; is the number of distinct inputs to be selected between.&lt;/p&gt;

&lt;p&gt;A non-traditional looking truth table will summarize this behavior succinctly:&lt;/p&gt;

&lt;p&gt;For a mux with data inputs A and B:&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;SEL&lt;/th&gt;
      &lt;th&gt; &lt;/th&gt;
      &lt;th&gt;Out&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;A&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;B&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;Perhaps more traditionally for the case where A and B are both 1 bit:&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;SEL&lt;/th&gt;
      &lt;th&gt;A&lt;/th&gt;
      &lt;th&gt;B&lt;/th&gt;
      &lt;th&gt; &lt;/th&gt;
      &lt;th&gt;OUT&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;You could go create this out of individual gates at this point - an exercise which is left up to the user.&lt;/p&gt;

&lt;p&gt;Just like we’ve ganged &lt;script type=&quot;math/tex&quot;&gt;N&lt;/script&gt; flip-flops together in parallel to make an &lt;script type=&quot;math/tex&quot;&gt;N&lt;/script&gt; bit register, you can also gang &lt;script type=&quot;math/tex&quot;&gt;N&lt;/script&gt; 1-bit mux’s together to make an &lt;script type=&quot;math/tex&quot;&gt;N&lt;/script&gt; bit mux, which is what we’ll need for Earth clock.&lt;/p&gt;

&lt;p&gt;The multiplexer is used enough that it gets its own special symbol. Here’s one drawn where A and B are both 4 bits wide.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/mux.png&quot; alt=&quot;Multiplexer symbol&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;new-dawn&quot;&gt;New Dawn&lt;/h4&gt;

&lt;p&gt;In particular, when our “new day detection” circuitry indicates that the next second is the start of a new day (and the current time should therefor be 0), we can use that 1-bit output and a mux to switch the value of the input to the registers:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/earthAlarmClock.png&quot; alt=&quot;Simple Earth Alarm Clock&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Here, we see that when our “next-day” detection logic indicates the next second should be 0, we pass in a constant value of all-0-bits to the input of the register. In all other cases, we continue to pass the same thing we used to pass - current time + 1.&lt;/p&gt;

&lt;p&gt;The alarm circuitry would need very little adjustment - only to increase the total number of input switches used to select the “alarm” time.&lt;/p&gt;

&lt;p&gt;And just like that, we’ve constructed a functional earth alarm clock. Good job team!&lt;/p&gt;

&lt;h2 id=&quot;ram&quot;&gt;RAM&lt;/h2&gt;

&lt;p&gt;While our alarm clock adventures have been fun, it turns most people &lt;a href=&quot;https://www.amazon.com/s?k=alarm+clock&amp;amp;ref=nb_sb_noss_2&quot;&gt;don’t build their alarm clocks from scratch.&lt;/a&gt;. The ones on the market have far more features and it rarely makes sense to build one yourself like we described, unless you want to just have some fun.&lt;/p&gt;

&lt;p&gt;Building your own RAM chips is also not recommended for anything except leisure. However, it’s worthwhile going over the basics of what features a piece of Random-Access Memory has to support, and propose one way of going about doing this with the circuits we know about.&lt;/p&gt;

&lt;h3 id=&quot;accessing-randomly&quot;&gt;Accessing Randomly&lt;/h3&gt;

&lt;p&gt;Computer Memory is a digital device which stores and recalls large chunks of data. As you may know, and as we already mentioned, RAM is an acronym which stands for “Random Access Memory” - it means that a user of a RAM chip can access any particular part of memory at any time. It also implies that the user can write a new value to any particular part of memory at any time. As a side note, the other common type of memory is called ROM, for “Read Only Memory”. This type can store information, but not change it.&lt;/p&gt;

&lt;p&gt;When reading and writing to a RAM chip, the &lt;em&gt;location&lt;/em&gt; where things are stored is referred to as an “address”. In general, on a chip, the addresses are just numbered 0, 1, 2, … up through the maximum size of the chip. When you see a chip say it can store 1 MB (&lt;a href=&quot;https://en.wikipedia.org/wiki/Megabyte&quot;&gt;megabyte&lt;/a&gt; ~= &lt;script type=&quot;math/tex&quot;&gt;10^6&lt;/script&gt; bytes), this refers to the quantity of addresses available for storing data. If each address refers to one byte, the memory is said to be &lt;em&gt;byte addressable&lt;/em&gt; and the addresses would go from 0 up through 1048576 or so.&lt;/p&gt;

&lt;p&gt;Think of addresses just like the addresses on houses. Each house has a mailbox, and each house has a number on it. When you want to “store” (ie give) data to a certain mailbox, you provide both the “data” (your package or letter) and the address to put it in. A mailman then does the job of storing the data in the right spot. The data remains there till the owner recalls it from the appropriate mailbox. The numbers of the address help coordinate the data going to the right spot, so the right person gets it back out.&lt;/p&gt;

&lt;p&gt;Of course, in real RAM, there’s usually no restrictions on who can read or write to each address - unlike in the US, where &lt;a href=&quot;https://www.law.cornell.edu/uscode/text/18/1702&quot;&gt;taking someone else’s mail is a felony&lt;/a&gt;. Computers are supposed to be general purpose computation devices, so it’s rare that hardware enforces read/write restrictions based on identity. This sort of security, if required, is usually added by software or specialized processor hardware.&lt;/p&gt;

&lt;h3 id=&quot;the-prototype-ram-chip&quot;&gt;The Prototype RAM Chip&lt;/h3&gt;

&lt;p&gt;Every RAM chip will have to have a few connections:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;An input for the address from which to read data&lt;/li&gt;
  &lt;li&gt;An output which contains the data recalled from the read address&lt;/li&gt;
  &lt;li&gt;An input for the address to which to write data&lt;/li&gt;
  &lt;li&gt;An input for the data to write at the write address&lt;/li&gt;
  &lt;li&gt;A clock to synchronize read/write operations with data input and output.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Depending on what brand and model of RAM chip you have, you may see certain of these functions tied together (ie one address for read/write) or split apart (ie two clocks - one for read and one for write). Some have enable lines to turn on or off read/write functionality as needed. All these features are nice to have, but add cost and increase pin count. So, it’s all just an engineering tradeoff. Pick the RAM chip with all the features you &lt;em&gt;need&lt;/em&gt;, and that matches your budget.&lt;/p&gt;

&lt;p&gt;When a processor wants to store a value, the process is generally:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Assert the bits of value onto the data input&lt;/li&gt;
  &lt;li&gt;Assert the bits of the address onto the write address input&lt;/li&gt;
  &lt;li&gt;Allow the clock cycle to occur.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Reading back a value is very similar:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Assert the bits of the address onto the read address input&lt;/li&gt;
  &lt;li&gt;Allow the clock cycle to occur&lt;/li&gt;
  &lt;li&gt;Read the value of the bits on the data output&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Note that most RAM chips do not store their value over power cycle. When you remove power from the device, all the data disappears. When you re-apply power, the device reads all 0’s or all 1’s (depends on the underlying technology).&lt;/p&gt;

&lt;h3 id=&quot;internals-of-a-theoretical-ram-chip&quot;&gt;Internals of a Theoretical RAM Chip&lt;/h3&gt;

&lt;p&gt;I don’t want to get too deep into how to design the internals of the RAM chip. This is because the actual way they are made is highly optimized (some using only a single transistor per bit storage), and it looks very dissimilar from the usual gate logic we think about digital logic in. Still, it is very possible to construct a RAM chip from only the gates and flip-flops we already know about, and is an interesting thought experiment to figure out how to make it happen.&lt;/p&gt;

&lt;p&gt;Here’s the highlights of a plausible (abet inefficient) way to do it - I’ll leave the details of the implementation up to the reader to sort out.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Each address has, at its core, an 8-bit register (same as above) to store the value.
    &lt;ul&gt;
      &lt;li&gt;Every register is fed from the same clock.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;One giant MUX at the output takes the read address input, and selects the proper register to pass to the output&lt;/li&gt;
  &lt;li&gt;Each register’s output loops back around to its input through a mux and some digital logic, such that the value &lt;em&gt;usually&lt;/em&gt; never changes (output of register fed right back to input).
    &lt;ul&gt;
      &lt;li&gt;However, that input logic is set up such that when the write address input matches that register’s address, the data from the write data input is used instead.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;There are some key inefficiencies with this system, however:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Muxes which select between 1,000,000 inputs are ineffective to make as a single unit. It’s more efficient to split it up into lots of little tiny pieces.&lt;/li&gt;
  &lt;li&gt;At scale, gate delays may start to limit clock speed. Having additional buffers to temporarily store the read/write values while the internal circuitry changes state can help mitigate this
    &lt;ul&gt;
      &lt;li&gt;It’s worthwhile noting that in modern processors, RAM is usually asynchronous from and slower than the main processor. This can sometimes be part of the reason extra chips are needed on a motherboard to “drive” the RAM chips, converting data between the domain of the processor and the memory circuits.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;The loop-back circuitry on every register can be eliminated by having two clocks (one for read, one for write), or some set of “enable bit” inputs that the processor controls - writes are commanded only when required.&lt;/li&gt;
  &lt;li&gt;The read-mux and write-mux circuitry can sometimes be combined into the inside of the register in an enable/disable fashion.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;For more info on “real” RAM chips, search around for “Memory Cell”, like on &lt;a href=&quot;https://en.wikipedia.org/wiki/Memory_cell_(computing)&quot;&gt;wikipedia&lt;/a&gt;. The key takeaway is that there are a huge number of different ways to implement RAM, but that shouldn’t matter. As far as the processor is concerned, it’s just an abstract device which can store and recall data from little mailboxes we call “addresses”&lt;/p&gt;

&lt;h2 id=&quot;next-steps---where-are-we-going&quot;&gt;Next Steps - Where are we going?&lt;/h2&gt;

&lt;p&gt;With the introduction of combinational circuits like adders and mux’s, and some sequential logic like registers and RAM, we’re now &lt;em&gt;almost&lt;/em&gt; ready to start delving into how these are combined together in a traditional processor. We’ll start to cover this in a primer discussion on &lt;a href=&quot;/blog_posts/2019/07/22/processor_arch_primer.html&quot;&gt;Processor Architecture&lt;/a&gt;.&lt;/p&gt;

&lt;div class=&quot;footnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:1&quot;&gt;
      &lt;p&gt;Flaw - or &lt;em&gt;limitation&lt;/em&gt; or &lt;em&gt;opportunity&lt;/em&gt;. All words could apply, just pick the one that says what you want to say. &lt;a href=&quot;#fnref:1&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:2&quot;&gt;
      &lt;p&gt;Or at least, it ought to. Sometimes the marketing department has other ideas. But we still like them, because they help sell the things, which makes money, and lets the engineers make more things, and have food to eat. &lt;a href=&quot;#fnref:2&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:3&quot;&gt;
      &lt;p&gt;Turns out, because of gate delay, the ripple-carry adder is actually a bad design for an adder circuit. Think about what happens if you had 1000 stages. How long do you have to wait for the full result to be available? Think about how many gate propagations are needed to calculate the final carry-out signal. Dis nasty. &lt;a href=&quot;#fnref:3&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:4&quot;&gt;
      &lt;p&gt;Forgive the odd drawing here - you can ignore the numbers right by the gates. I’m testing out using &lt;a href=&quot;http://kicad-pcb.org/&quot;&gt;KiCad&lt;/a&gt; for schematic capture and design. It’s a bit cumbersome for these educational purposes, but can draw simple logic diagrams well. Looks super powerful as an electronic schematic and printed circuit board design tool though! I highly recommend it so far! &lt;a href=&quot;#fnref:4&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt; &lt;a href=&quot;#fnref:4:1&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;sup&gt;2&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;</content><author><name></name></author><summary type="html">This post is the continuation of Part 1 in our series on digital devices.</summary></entry><entry><title type="html">Digital Devices</title><link href="/blog_posts/2019/06/26/digital_devices.html" rel="alternate" type="text/html" title="Digital Devices" /><published>2019-06-26T09:30:00-05:00</published><updated>2019-06-26T09:30:00-05:00</updated><id>/blog_posts/2019/06/26/digital_devices</id><content type="html" xml:base="/blog_posts/2019/06/26/digital_devices.html">&lt;p&gt;&lt;img src=&quot;/assets/word_problems.jpg&quot; alt=&quot;word problems from Bill Waterson&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Calvin and Hobbes, by Bill Waterson&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&quot;on-word-problems&quot;&gt;On Word Problems&lt;/h2&gt;

&lt;p&gt;As engineers, we almost always start with word problems. You know those paragraphs that your math teacher writes out that you have to &lt;em&gt;read&lt;/em&gt; and then they make you extract the useful information to formulate some formulas, then solve them, then get the actual answer? Yea, those. I used to love those, because the paragraph-format meant the teacher couldn’t fit as many problems on one page, which meant shorter homework assignments!&lt;/p&gt;

&lt;p&gt;Never in my professional life have I ever been asked “what’s &lt;script type=&quot;math/tex&quot;&gt;465 + 236&lt;/script&gt;?”. Many times, I’ve had someone come to my desk and ask me a question that took ten sentences to explain, but at the end of the day all I had to do was calculate &lt;script type=&quot;math/tex&quot;&gt;465 + 236&lt;/script&gt;. That and listen to them, which is a whole skill (nay, art?) unto itself.&lt;/p&gt;

&lt;p&gt;In previous posts, we’ve seen how logic gates can be combined to manipulate bits. There’s obviously a ton of different ways you could combine a set of bits… OR’ing them together, AND’ing them together, some combination of the two… But, why would you do such things?&lt;/p&gt;

&lt;p&gt;Word problems. Every engineering problem starts as a word problem. So to learn about digital devices, we’re going to frame a couple word problems. Some of them may seem a bit odd at first, but I promise they’re building up to something very useful. Keep in mind, we’re laying the foundation for understanding the guts of a computer, which is going to help us write better software.&lt;/p&gt;

&lt;h2 id=&quot;rocket-launch-controller&quot;&gt;Rocket Launch Controller&lt;/h2&gt;

&lt;p&gt;Well, a contrived one at least. Part of one, not the whole thing.&lt;/p&gt;

&lt;p&gt;Let’s imagine a usual rocket launch. We’re sending some people into space atop a very &lt;em&gt;very&lt;/em&gt; powerful flaming pushy thing. You want to be sure everyone is OK with going to space before you actually try to go to space.&lt;/p&gt;

&lt;p&gt;Mission control is keeping track of the launch, and  has the responsibility of initiating it. Maybe we could give them one big launch button. But, this could be problematic - what if someone trips and falls and lands on the button? Then our rocket gets launched unexpectedly. This could be bad &lt;script type=&quot;math/tex&quot;&gt;^{citation needed}&lt;/script&gt;.&lt;/p&gt;

&lt;p&gt;For safety’s sake, let’s build two buttons and put them on opposite sides of the room. The rocket shouldn’t launch unless two &lt;em&gt;different&lt;/em&gt; launch control engineers push both the buttons at the same time. “Hey Bob, ya ready?” “Yea Joe, let’s light this candle!” “Ok, push the button” “Sounds good!” BWWWUWUSUSHSHSHSHSHSHSHSHHHHhhhhhhh……&lt;/p&gt;

&lt;p&gt;But, we also have astronauts in the capsule. Mission control is pretty good at their jobs, but they aren’t at the rocket. Despite all their instruments, they still don’t hear, feel, or smell&lt;sup id=&quot;fnref:1&quot;&gt;&lt;a href=&quot;#fn:1&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt; the behavior of the rocket. Maybe it’s wise to give our astronaut friends a “kill switch” of sorts inside the capsule. That way, if something seems off, they can activate some sort of “emergency stop” or “override” to prevent launch control from starting the rocket.&lt;/p&gt;

&lt;p&gt;Buttons make great sources of boolean inputs. Though we won’t go into the details just yet, suffice to say that you have three boolean inputs, representing each of our three buttons. We’ll call the two in the launch control room &lt;script type=&quot;math/tex&quot;&gt;L_1&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;L_2&lt;/script&gt;. We’ll call the “emergency-stop” button near the astronauts &lt;script type=&quot;math/tex&quot;&gt;E&lt;/script&gt;. For all buttons, a value of True indicates the button is pressed, and False indicates it’s not pressed.&lt;/p&gt;

&lt;p&gt;We will have a single output called &lt;script type=&quot;math/tex&quot;&gt;A&lt;/script&gt;. When it’s True, it will trigger the ignitors to start the rocket, and send the thing to space. When False, the rocket remains on the launch pad.&lt;/p&gt;

&lt;p&gt;How do we want to design this digital circuit to control the launch functionality as described? Let’s break it down into little chunks.&lt;/p&gt;

&lt;p&gt;The launch room is kind of its own entity, with its own behavior, and own set of inputs. Let’s deal with that one first.&lt;/p&gt;

&lt;p&gt;What is the information that comes out of the launch room that the rocket ignitors care about? I’d say that the information the rocket cares about is “Both buttons or pressed” - either they’re both pressed, or their not both pressed. Let’s call this intermediate value &lt;script type=&quot;math/tex&quot;&gt;B&lt;/script&gt;.&lt;/p&gt;

&lt;p&gt;Looking inside the launch room, the logic should be pretty simple. Two inputs, one output. Let’s enumerate what we want to happen for each input:&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;&lt;script type=&quot;math/tex&quot;&gt;L_1&lt;/script&gt;&lt;/th&gt;
      &lt;th&gt;&lt;script type=&quot;math/tex&quot;&gt;L_2&lt;/script&gt;&lt;/th&gt;
      &lt;th&gt; &lt;/th&gt;
      &lt;th&gt;&lt;script type=&quot;math/tex&quot;&gt;B&lt;/script&gt;&lt;/th&gt;
      &lt;th&gt; &lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;No button is pressed. Don’t Launch.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;Only one button is pressed. Don’t Launch Yet.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;Only one button is pressed. Don’t Launch Yet.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;Both buttons are pressed. Go for Launch!&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;Astute readers will notice that this actually is a very familiar function - it’s just an AND gate!&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;B = L_1 \cdot L_2&lt;/script&gt;

&lt;p&gt;&lt;img src=&quot;/assets/mission_control.png&quot; alt=&quot;mission control button schematic&quot; /&gt;&lt;/p&gt;

&lt;p&gt;There we go, quite simple!&lt;/p&gt;

&lt;p&gt;Now let’s move on to the astronauts. They’ve got one button that when pressed should indicate “inhibit launch”.&lt;/p&gt;

&lt;p&gt;It’s generally a good idea to try to keep things as similar as possible. Since Launch Control has a single output that indicates “Go for Launch”, lets give our astronauts the same output. We need to design a circuit that takes their inhibit button value and converts it into a “Go for launch” output. We’ll call the astronaut output &lt;script type=&quot;math/tex&quot;&gt;C&lt;/script&gt;. Again enumerating with a truth table:&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;&lt;script type=&quot;math/tex&quot;&gt;E&lt;/script&gt;&lt;/th&gt;
      &lt;th&gt; &lt;/th&gt;
      &lt;th&gt;&lt;script type=&quot;math/tex&quot;&gt;C&lt;/script&gt;&lt;/th&gt;
      &lt;th&gt; &lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;Astronauts are not pushing their button. Everything must be ok, go for launch!&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;Astronauts detected a problem and pushed their button! Don’t Launch!&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;Astute readers will again notice this is actually a very familiar function - it’s just a NOT gate.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;C = \overline{E}&lt;/script&gt;

&lt;p&gt;&lt;img src=&quot;/assets/astronaut_button.png&quot; alt=&quot;Astronaut button schematic&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Excellent! We have now devices for both the Launch Control room and the Astronauts capsule controls, each with an output that says “Light the rocket” or “Don’t light the rocket”. The rocket ignition mechanism now has to take these two signals, and combine them together. Note from our initial requirement, we know we don’t want to launch the rocket unless both the astronauts and launch control decide it’s time to go.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;&lt;script type=&quot;math/tex&quot;&gt;B&lt;/script&gt;&lt;/th&gt;
      &lt;th&gt;&lt;script type=&quot;math/tex&quot;&gt;C&lt;/script&gt;&lt;/th&gt;
      &lt;th&gt; &lt;/th&gt;
      &lt;th&gt;&lt;script type=&quot;math/tex&quot;&gt;A&lt;/script&gt;&lt;/th&gt;
      &lt;th&gt; &lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;No one wants to launch the rocket. Don’t Launch.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;Astronauts say they’re ok to launch, but Launch Control doesn’t agree. Don’t Launch Yet.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;Launch Control wants to go, but astronauts saw a problem. Don’t Launch Yet.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;Astronauts say they are good to go, and Launch Control says good to go!  Light the Rocket!&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;Even the least astute of readers should be able to recognize this now. It’s another AND gate!&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;A = B \cdot C&lt;/script&gt;

&lt;p&gt;We can now put all 3 pieces of the puzzle together. Substituting equations:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;A = (B) \cdot (C)&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;A = (L_1 \cdot L_2) \cdot \overline{E}&lt;/script&gt;

&lt;p&gt;In diagrams, we’d draw this as:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/full_schematic.png&quot; alt=&quot;Full Schematic&quot; /&gt;&lt;/p&gt;

&lt;p&gt;This simple logic diagram shows how we could implement logic to accomplish our basic launch control system.&lt;/p&gt;

&lt;h3 id=&quot;notes-on-subdividing&quot;&gt;Notes on Subdividing&lt;/h3&gt;

&lt;p&gt;Admittedly, this is a pretty simple system, and we took a very verbose and roundabout way to design it. I bet many of you saw the ending well before we got there. That’s perfectly fine! The big takeaway is not just the answer itself, but rather dividing the problem up into useful pieces. In this context, “useful” implies that each one is solvable on its own, and represents some meaningful small piece of computation. If you notice, you can easily draw boxes around the three physical locations we discussed:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/marked_up_schematic.png&quot; alt=&quot;Marked up schematic&quot; /&gt;&lt;/p&gt;

&lt;p&gt;The individual pieces may not be implemented by the same computer! You might have to have each piece on a different machine, since they’re in physically different places. This diagram and design doesn’t at all get into how one might transfer a boolean value from one place to another (radio? super long wire?), but for lots of purposes that doesn’t matter. Imagine your boss came up and asked “What does the system do”? They don’t care about the implementation details, they care about functionality. This would be a great diagram to show the high level behavior of the system, without getting bogged down on communication, button size, or other implementation details.&lt;/p&gt;

&lt;p&gt;The wise engineer says to create designs (and present designs) at the easiest and most useful level of abstraction. The experienced and artful engineer can identify exactly what that level of abstraction is in their sleep.&lt;/p&gt;

&lt;h3 id=&quot;design-flaw&quot;&gt;Design Flaw&lt;/h3&gt;

&lt;p&gt;The critical student will have noticed that there may be a few gaps in our design.&lt;/p&gt;

&lt;p&gt;One of them that I’ll address - the astronaut button. Let’s say that our friends detect a problem and want to prevent launch. With our current logic, if they tap their button, they’ll momentarily inhibit the launch, but as soon as they take their finger away the button springs back, allowing the launch again. It would stink to force them to have to hold down the button the whole time. We’d probably want to remember whether they’ve pressed it or not, and inhibit launch until someone corrects the issue that caused them to hit the inhibit button in the first place.&lt;/p&gt;

&lt;p&gt;I can think of two ways to do this “remembering”. One is mechanically - don’t use a button, use something more like a light switch that doesn’t “spring-back” to the off position when you’re done. THe other is to remember the button press in software. This requires using &lt;em&gt;memory&lt;/em&gt;, which is a concept we’ll cover later in this post.&lt;/p&gt;

&lt;h2 id=&quot;adders&quot;&gt;Adders&lt;/h2&gt;

&lt;p&gt;We’re going to move on to a slightly more abstract, but much more realistic example.&lt;/p&gt;

&lt;h3 id=&quot;binary-addition&quot;&gt;Binary Addition&lt;/h3&gt;

&lt;p&gt;Recall from the &lt;a href=&quot;/blog_posts/2019/06/10/binary.html&quot;&gt;binary lesson how we can add together base-2 numbers&lt;/a&gt; the same way we add together familiar base-10 numbers. The algorithm that I learned back in the day was:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Line up the two numbers on top of each other, keeping each place vertically aligned.&lt;/li&gt;
  &lt;li&gt;Starting from the one’s place, add together each single digit number&lt;/li&gt;
  &lt;li&gt;If the result of a particular addition is 10 or greater, “overflow” or “carry” into the next column.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;The exact same process works in binary. Recall:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;67_{10} = 01000011_{2}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;5_{10} = 00000101_{2}&lt;/script&gt;

&lt;p&gt;Adding these two numbers in base-10, I get a result of 72. Let’s do it in binary, to show how a thing that only knows 1 and 0 might go about doing the same calculation:&lt;/p&gt;

&lt;p&gt;First, we align the numbers:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{align}
01000011&amp; \\
\underline{+\quad 00000101}&amp; \\
 &amp;
\end{align} %]]&gt;&lt;/script&gt;

&lt;p&gt;Then, starting from the least significant bit, we start adding.&lt;/p&gt;

&lt;p&gt;Note that &lt;script type=&quot;math/tex&quot;&gt;1_{2} + 1_{2} = 10_{2}&lt;/script&gt; (This is just &lt;script type=&quot;math/tex&quot;&gt;1_{10} + 1_{10} = 2_{10}&lt;/script&gt;, which you presumably learned in 1st grade.) Since the addition of two &lt;script type=&quot;math/tex&quot;&gt;1&lt;/script&gt;’s has created a new digit, we have to carry it over to the next column:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{align}
      10&amp; \\
01000011&amp; \\
\underline{+\quad 00000101}&amp; \\
0&amp;
\end{align} %]]&gt;&lt;/script&gt;

&lt;p&gt;Rinse-wash-repeat.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;1_{2} + 1_{2} + 0_{2} = 1_{2} + 1_{2} = 10_{2}&lt;/script&gt;

&lt;p&gt;Therefor, we have to carry again.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{align}
     110&amp; \\
01000011&amp; \\
\underline{+\quad 00000101}&amp; \\
00&amp;
\end{align} %]]&gt;&lt;/script&gt;

&lt;p&gt;We continue this process until we’ve covered all the bits in the number, and arrive at our result:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;1001000_{2} = 72_{10}&lt;/script&gt;

&lt;p&gt;Huzzah! We have done the calculation using only 1’s and 0’s. Hey, digital logic uses only 1’s and 0’s. Do you think we could design some circuitry to do this? You bet your bottom dollar we can!&lt;/p&gt;

&lt;h3 id=&quot;patterns-in-binary-addition&quot;&gt;Patterns in Binary Addition&lt;/h3&gt;

&lt;p&gt;To build the logic, we’ll start by breaking down the problem. Look at a particular column of the above addition operation. Let’s try to describe its’ properties in general:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;It takes two bits as input, one each from the numbers we are trying to add.&lt;/li&gt;
  &lt;li&gt;A third bit comes in from the previous step, to indicate whether the previous step resulted in a “carry” operation or not.&lt;/li&gt;
  &lt;li&gt;It contributes one bit to the result number&lt;/li&gt;
  &lt;li&gt;It also may pass a “carry” bit to the next step&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;As a bit of bookkeeping, let’s first write out a list of all the possible math facts we could need. Remembering that addition is associative:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;0_{2} +  0_{2} +  0_{2}  = 00_{2}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;0_{2} +  0_{2} +  1_{2}  = 00_{2}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;0_{2} +  1_{2} +  1_{2}  = 10_{2}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;1_{2} +  1_{2} +  1_{2}  = 11_{2}&lt;/script&gt;

&lt;p&gt;Since we’re talking about only one stage, we’ll indicate &lt;em&gt;which&lt;/em&gt; stage that is with an index subscript. The first stage will have subscript &lt;script type=&quot;math/tex&quot;&gt;0&lt;/script&gt;, the next subscript &lt;script type=&quot;math/tex&quot;&gt;1&lt;/script&gt; and so on. Some particular (but unspecified) stage - the “&lt;script type=&quot;math/tex&quot;&gt;i&lt;/script&gt;‘th stage” - will have subscript &lt;script type=&quot;math/tex&quot;&gt;i&lt;/script&gt;. As a matter of notation, when looking at the &lt;script type=&quot;math/tex&quot;&gt;i&lt;/script&gt;‘th stage, the &lt;em&gt;next&lt;/em&gt; stage will be &lt;script type=&quot;math/tex&quot;&gt;i+1&lt;/script&gt;, and the previous stage will be &lt;script type=&quot;math/tex&quot;&gt;i-1&lt;/script&gt;. We’ll have to explicitly handle the end-cases, but ignore them for now - just think about the middle bits.&lt;/p&gt;

&lt;p&gt;To draw this a bit more clearly, let’s cover all 3 inputs and both outputs in a table.&lt;/p&gt;

&lt;p&gt;We’ll call the two bits to add &lt;script type=&quot;math/tex&quot;&gt;A_{i}&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;B_{i}&lt;/script&gt;, and the result &lt;script type=&quot;math/tex&quot;&gt;R_{i}&lt;/script&gt;. Each stage will also output a Carry signal called &lt;script type=&quot;math/tex&quot;&gt;C_{i}&lt;/script&gt;. Since each stage also takes an input from the previous stage’s carry signal, we’ll denote this input with &lt;script type=&quot;math/tex&quot;&gt;C_{i-1}&lt;/script&gt;&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;&lt;script type=&quot;math/tex&quot;&gt;A_{i}&lt;/script&gt;&lt;/th&gt;
      &lt;th&gt;&lt;script type=&quot;math/tex&quot;&gt;B_{i}&lt;/script&gt;&lt;/th&gt;
      &lt;th&gt;&lt;script type=&quot;math/tex&quot;&gt;C_{i-1}&lt;/script&gt;&lt;/th&gt;
      &lt;th&gt; &lt;/th&gt;
      &lt;th&gt;&lt;script type=&quot;math/tex&quot;&gt;R_{i}&lt;/script&gt;&lt;/th&gt;
      &lt;th&gt;&lt;script type=&quot;math/tex&quot;&gt;C_{i}&lt;/script&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;single-bit-adder&quot;&gt;Single Bit Adder&lt;/h3&gt;

&lt;p&gt;A single bit adder will be a device with three inputs (the two bits to add, plus a carry-in bit). It is actually two independent circuits, outputting the Result bit and the Carry-out bit. We’ll design each one, one at a time.&lt;/p&gt;

&lt;h4 id=&quot;result-bit&quot;&gt;Result Bit&lt;/h4&gt;

&lt;p&gt;If you stare at the truth table hard enough, you might notice that the result bit is 1 whenever the number of input signals is &lt;em&gt;odd&lt;/em&gt;. There are more algorithmic methods you can use to determine this, but recognizing this pattern lets you make the quick shortcut. Recall from previous posts that an &lt;em&gt;XOR&lt;/em&gt; gate outputs 1 when an odd number of its inputs are 1. So, we’ll use an XOR gate:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;R_{i} = A_{i} \oplus B_{i} \oplus C_{i-1}&lt;/script&gt;

&lt;h4 id=&quot;carry-out-bit&quot;&gt;Carry Out Bit&lt;/h4&gt;

&lt;p&gt;The carry out bit also has a bit of a pattern to it. Notice that it is true when at least two inputs are true. This can be covered by a series of OR’ed together AND outputs as such:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;C_{i} = A_{i} B_{i} + A_{i} C_{i-1} + B_{i} C_{i-1}&lt;/script&gt;

&lt;p&gt;Again there are algorithms you can use to derive this equation from the truth table, but if you stare at it hard enough, you should be able to convince yourself that this equation is both accurate, and makes sense. For example, think about why we don’t have to handle the all-three-inputs-true case explicitly.&lt;/p&gt;

&lt;h4 id=&quot;schematic&quot;&gt;Schematic&lt;/h4&gt;

&lt;p&gt;Based on our observation of the truth table, we can put together this device that can compute one column of the “add two bytes” problem:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/single_bit_adder.png&quot; alt=&quot;single bit adder&quot; /&gt;&lt;/p&gt;

&lt;p&gt;To use many of these devices in larger units, we’ll use an &lt;em&gt;abstraction&lt;/em&gt; where we draw just the inputs and outputs, and hide the details of the guts.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/single_bit_adder_abstraction.png&quot; alt=&quot;abstraction of single bit adder&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;ripple-carry-adder&quot;&gt;Ripple-carry Adder&lt;/h3&gt;

&lt;p&gt;The Ripple-carry Adder is a logical next-step to expand the single-bit adder. Earlier in the post we showed the algorithm for doing binary addition. Since it’s a bunch of rinse-wash-repeat steps, it stands to reason that we could make one circuit to do each step, then replicate and string them together. That’s exactly what we’ve done with the single-bit adder - we’ve made one circuit that can perform one step of the addition. A Ripple-carry Adder is simply a set of single-bit adders chained together to do addition of a full byte.&lt;/p&gt;

&lt;h3 id=&quot;joining-chunks-together&quot;&gt;Joining chunks together&lt;/h3&gt;

&lt;p&gt;The hookup is pretty much what you’d expect: Every bit in input bytes &lt;script type=&quot;math/tex&quot;&gt;A&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;B&lt;/script&gt; is piped to the proper single-bit adder stage. The carry bits are passed from one layer to the next. The 0th carry-in bit is hardcoded to zero. The final output is an output of the Ripple-carry Adder, and can be used to know when the sum of the two numbers is outside the range of representable digits by that fixed number of single-bit adders.&lt;/p&gt;

&lt;p&gt;For a 4-bit Ripple carry adder, the circuit diagram would look like this:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/four_bit_adder.png&quot; alt=&quot;four bit adder&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Notice how the “carry-out” from each stage &lt;em&gt;ripples&lt;/em&gt; into the next stage. Hence the name. Someone was clever like that.&lt;/p&gt;

&lt;p&gt;Hopefully you can see - if you need more bits (say, 8, or 64?), you just add more stages.&lt;/p&gt;

&lt;h2 id=&quot;next-steps---where-are-we-going&quot;&gt;Next Steps - Where are we going?&lt;/h2&gt;

&lt;p&gt;We’ve discussed digital circuits which are capable of transforming inputs into outputs, but not yet discussed how to create circuits which can remember past events. This will be a critical step if we want to be able to store any data while running our computer programs. We’ll delve into this &lt;a href=&quot;/blog_posts/2019/07/06/digital_devices_part2.html&quot;&gt;in Part 2!&lt;/a&gt;&lt;/p&gt;

&lt;div class=&quot;footnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:1&quot;&gt;
      &lt;p&gt;Yes, smell. A good engineer uses &lt;em&gt;most&lt;/em&gt; of their senses! Learn the smell of burning electronics, and learn to shut off the power as soon as you smell it! It’s a great way to identify the source of issues, and get early detection of a failure - you can often smell it before you see smoke. Of course, be careful not to inhale anything super toxic. For that same toxic ingestion reason, I don’t usually recommend the sense of taste for writing software. &lt;a href=&quot;#fnref:1&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;</content><author><name></name></author><summary type="html"></summary></entry><entry><title type="html">Introduction to Electronics Pt 2 - the Digital Revolution</title><link href="/blog_posts/2019/06/15/electronics_for_digital.html" rel="alternate" type="text/html" title="Introduction to Electronics Pt 2 - the Digital Revolution" /><published>2019-06-15T09:30:00-05:00</published><updated>2019-06-15T09:30:00-05:00</updated><id>/blog_posts/2019/06/15/electronics_for_digital</id><content type="html" xml:base="/blog_posts/2019/06/15/electronics_for_digital.html">&lt;h2 id=&quot;introduction&quot;&gt;Introduction&lt;/h2&gt;

&lt;p&gt;A mentor from &lt;a href=&quot;https://www.thebluealliance.com/team/2102&quot;&gt;Team 2102&lt;/a&gt; had a great suggestion on how to re-work the electronics section to introduce things from a digital-first perspective. This post is a result of that rework, plus some extra facts I find useful.&lt;/p&gt;

&lt;h2 id=&quot;a-brief-history&quot;&gt;A Brief History&lt;/h2&gt;

&lt;p&gt;Doing digital electronics fundamentally requires devices that have &lt;em&gt;discrete&lt;/em&gt; states - on and off. Resistors, Capacitors, Inductors, and the like are called &lt;em&gt;linear&lt;/em&gt; electronic devices because, simply put, they do not have on/off states. They transition smoothly from one voltage/current operation point to another, usually in a very linear fashion (if you look at the right variables).&lt;/p&gt;

&lt;p&gt;Compare this with a light switch in your house - it has no in-between states. As you slide it from the up position to the down position, the state rapidly changes between on and off at some point (defined by the mechanical construction of the inner components). This is the sort of behavior a system that works with 1’s and 0’s exclusively will need to do calculation.&lt;/p&gt;

&lt;p&gt;The earliest of electronic calculating machines used &lt;a href=&quot;https://en.wikipedia.org/wiki/Relay&quot;&gt;electronic &lt;em&gt;relays&lt;/em&gt;.&lt;/a&gt; Just like the &lt;a href=&quot;https://www.vexrobotics.com/217-0220.html&quot;&gt;Vex Spike&lt;/a&gt; double relay you may be familiar with - these are simple devices that switch an output on and off in response to an input voltage. The input voltage generates a small magnetic field in a coil of wire, which mechanically moves contacts from one position to another, completing or breaking a circuit. It’s just a switch that can be turned on and off with electricity.&lt;/p&gt;

&lt;p&gt;Relays have their faults - the coils can get &lt;em&gt;very&lt;/em&gt; power hungry and dissipate a lot of energy as heat. Additionally, the presence of moving parts is always a source of failure, and relays can be unreliable. Additionally, the fact that a mechanism has to physically move from one location to another makes them relatively slow - to increase the speed you have to increase the forces on the mechanism, which leads to less reliability and even more power consumption.&lt;/p&gt;

&lt;p&gt;The next development was the invention of the &lt;a href=&quot;https://en.wikipedia.org/wiki/Vacuum_tube&quot;&gt;&lt;em&gt;vacuum tube&lt;/em&gt;&lt;/a&gt;. These little devices used heated metal grids to get electrons to flow from one point to another, within a near-airless environment in a glass tube. By carefully changing voltages on plates and aligning them in just the right way, you could use a very small control signal to turn on and off a larger current flow (very similar to a relay). Though also useful as amplifiers, they were easy to use as switches that can be turned on and off with electricity.&lt;/p&gt;

&lt;p&gt;Again though, there were disadvantages. Although switching speeds were vastly increased over mechanical relays, the glass-vacuum setup made them physically fragile. Just like light-bulbs, the glass could crack, or the internals could short out and break. Additionally, the heater element required lots of energy, and took time to “warm up” before it could be used. Still, they were practical enough that &lt;a href=&quot;https://en.wikipedia.org/wiki/List_of_vacuum_tube_computers&quot;&gt;many early computers&lt;/a&gt; were designed and built with them.&lt;/p&gt;

&lt;p&gt;The Transistor was the next development. &lt;a href=&quot;https://en.wikipedia.org/wiki/History_of_the_transistor&quot;&gt;Three gentlemen&lt;/a&gt; were awarded the nobel prize for inventing the “solid state” device to control current. Gone were the days of mechanical monsters or fragile glass tubes - their device was a simple hunk of specially-treated material with some wires coming out. Equal parts engineering and hard scientific research, Bell Labs and various universities rapidly developed the first prototypes into commercially marketable products, which in turn made them all the more common-place (and therefor cheap).&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://upload.wikimedia.org/wikipedia/commons/c/c2/Bardeen_Shockley_Brattain_1948.JPG&quot; alt=&quot;three inventors&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Modern processors aren’t even built out of manufactured transistors anymore - the &lt;em&gt;circuit chip&lt;/em&gt; is made up of transistors, and lots of other components, but all are created with a photomicrography process that literally eteches the components into a monolithic piece of silicon. But that’s a topic for a future post…&lt;/p&gt;

&lt;p&gt;For now, let’s delve into the materials used inside of the transistor to explain a bit about its functionality.&lt;/p&gt;

&lt;h2 id=&quot;semiconductors&quot;&gt;Semiconductors&lt;/h2&gt;

&lt;p&gt;Of particular interest to computer engineers is a very particular class of materials called &lt;em&gt;Semiconductors&lt;/em&gt; These materials have the ability to change between conductor and insulator depending on how voltages are applied to them.&lt;/p&gt;

&lt;h3 id=&quot;physical-construction&quot;&gt;Physical Construction&lt;/h3&gt;

&lt;p&gt;Semiconductors are primarily made of specially processed silicon, formed into a very regular lattice-like structure on the atomic level, then carefully “doped” with impurities that introduce mobile charged particles. These can be actual electrons, or a void where an electron could fit in (called a “hole”), which is effectively a positive charge carrier.&lt;/p&gt;

&lt;p&gt;Remember that a conductor has free particles to carry charge, while insulators do not. Undoped silicon is effectively an insulator, because all electrons are tightly bound into the lattice. Doped silicon does have extra electrons (or holes) which can move around, as they are not tightly bound to the lattice, and are therefor effectively conductors.&lt;/p&gt;

&lt;p&gt;Layers of differently-doped material are fused in specific physical configurations to construct useful devices.&lt;/p&gt;

&lt;p&gt;When a doped region with extra electrons is fused to a doped region with holes, some electrons naturally migrate into the holes near the junction. This forms what is called the “depletion layer” near the junction. This depletion layer is effectively an insulator, since there are no free electrons to carry current through the region.&lt;/p&gt;

&lt;h3 id=&quot;electrical-properties&quot;&gt;Electrical Properties&lt;/h3&gt;

&lt;p&gt;Applying a voltage across this depletion region will exert an extra force on the electrons. Depending on the direction of the voltage, you may end up with more electrons  hopping into holes (expanding the depletion region), or knocking electrons out of holes (shrinking the depletion region). As the voltage gets big enough to drive the depletion region to near zero size, the resistance of the material goes down, and it transforms into a conductor overall.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/diode.png&quot; alt=&quot;depletion layer and diode&quot; /&gt;&lt;/p&gt;

&lt;p&gt;This is the useful property of semiconductors - by applying a voltage to one part, the material property can be converted between insulator and conductor.&lt;/p&gt;

&lt;h3 id=&quot;transistor-as-a-switch&quot;&gt;Transistor as a Switch&lt;/h3&gt;

&lt;p&gt;It is commonly said that computers store information using 1’s and 0’s. These “bits” of information are represented inside the circuitry of the processor as high and low voltages. To store, combine, and manipulate the information, it is necessary to have circutry which can manipulate the high and low voltages dynamically.&lt;/p&gt;

&lt;p&gt;Transistors contain 3 or more regions of semiconductor material. The simplest type have what is referred to as a Base, Collector, and Emitter region.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/bjt.png&quot; alt=&quot;bjt diagram&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Usually the line diagram with the “arrow pointing in” is used to represent the transistor in schematics.&lt;/p&gt;

&lt;p&gt;By injecting a voltage (and tiny current) at the base, the motion of electrons causes an avalanche effect if the collector &amp;amp; emitter have a voltage across them. The tiny input force causes a much larger output force, though it saturates at a certain point. This association allows one electrical signal to impact the flow of another signal, much as a human turning a light switch on and off impacts the flow of electricity to a lamp.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/bjt_as_switch.png&quot; alt=&quot;bjt as switch&quot; /&gt;&lt;/p&gt;

&lt;p&gt;This switching action of the transistor is the basis upon which information can be manipulated. By carefully combining transistors, along with small numbers of other components, basic “logic gates” can be built up. These rudamentory gates have one or more inputs, and a single output, and computer boolean operations like AND, OR, and NOT with electronics.&lt;/p&gt;

&lt;p&gt;The exact construction of logic gates from transistors is beyond the scope of this blog because, indeed, learning about how it &lt;em&gt;actually&lt;/em&gt; works requires a much deeper dive into the various types of transistors available. In my opinion, this is a topic better suited for folks interested in designing processor circuitry, rather than writing software. For the curious, &lt;a href=&quot;http://hyperphysics.phy-astr.gsu.edu/hbase/Electronic/trangate.html&quot;&gt;HyperPhysics&lt;/a&gt; has some examples of how gates can be constructed from the BJT transistors we have explained already.&lt;/p&gt;

&lt;p&gt;Therefor, we make the following two abstractions:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;em&gt;A transistor is a device which controls the flow of electricity&lt;/em&gt;&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;Transistors can be combined to build logic gates, which implement basic logic functions&lt;/em&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Just remember these two, and you’ll be fine going forward!&lt;/p&gt;

&lt;h2 id=&quot;next-steps---where-are-we-going&quot;&gt;Next Steps - Where are we going?&lt;/h2&gt;

&lt;p&gt;We’ve scratched the surface of Analog, and shown how you can start to go Digital. If you haven’t yet, go lay the groundwork of some basic Digital concepts with &lt;a href=&quot;/blog_posts/2019/06/10/binary.html&quot;&gt;Binary&lt;/a&gt;.&lt;/p&gt;</content><author><name></name></author><summary type="html">Introduction</summary></entry><entry><title type="html">Boolean Logic</title><link href="/blog_posts/2019/06/14/boolean_logic.html" rel="alternate" type="text/html" title="Boolean Logic" /><published>2019-06-14T09:30:00-05:00</published><updated>2019-06-14T09:30:00-05:00</updated><id>/blog_posts/2019/06/14/boolean_logic</id><content type="html" xml:base="/blog_posts/2019/06/14/boolean_logic.html">&lt;p&gt;&lt;em&gt;“All you need is NAND… ba da da da da” - &lt;a href=&quot;http://publish.illinois.edu/loui/&quot;&gt;Professor Michael Loui&lt;/a&gt;, 2010, UIUC&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&quot;combining-bits&quot;&gt;Combining Bits&lt;/h2&gt;

&lt;p&gt;In this post, we’ll start to dig into how you combine bits together. &lt;a href=&quot;/blog_posts/2019/06/10/binary.html&quot;&gt;Previously&lt;/a&gt; we’ve looked at how to interpret, generate, and analyze sets of bits. Now we want to do operations on them. Just like how you add and subtract numbers, so to can 1’s and 0’s be combined and manipulated.&lt;/p&gt;

&lt;p&gt;If you remember our friend Mr. Boole from previous posts, what we’re about to go through is a primer on the logical system he formulated.&lt;/p&gt;

&lt;h2 id=&quot;boolean-functions&quot;&gt;Boolean Functions&lt;/h2&gt;

&lt;p&gt;Recall from the &lt;a href=&quot;/blog_posts/2019/06/01/math_primer1.html&quot;&gt;math primer&lt;/a&gt; how we looked at the concept of a &lt;em&gt;function&lt;/em&gt; as an &lt;a href=&quot;/blog_posts/2019/05/26/abstraction.html&quot;&gt;abstraction&lt;/a&gt; of mathematical behavior. Just like with normal base-10 numbers, functions can be defined for acting on boolean numbers too!&lt;/p&gt;

&lt;p&gt;We often describe a boolean function with what’s called a &lt;em&gt;truth table&lt;/em&gt;. Due to the &lt;em&gt;discrete&lt;/em&gt; nature of only allowing each input to be True or False, it’s often easy to completely enumerate the set of all possible inputs to the function.&lt;/p&gt;

&lt;p&gt;The functions we’ll concern ourselves with take &lt;script type=&quot;math/tex&quot;&gt;N&lt;/script&gt; inputs, and produce a single output.&lt;/p&gt;

&lt;p&gt;If you recall some of the math we learned in previous posts, you could probably have guessed that a function with &lt;script type=&quot;math/tex&quot;&gt;N&lt;/script&gt; boolean inputs has &lt;script type=&quot;math/tex&quot;&gt;2^N&lt;/script&gt; possible input combinations, which means it has &lt;script type=&quot;math/tex&quot;&gt;2^N&lt;/script&gt; outputs to describe in a truth table. Of course, each of those &lt;script type=&quot;math/tex&quot;&gt;2^N&lt;/script&gt; outputs will be simply 1 or 0, but &lt;em&gt;which ones are 1&lt;/em&gt; and &lt;em&gt;which ones are 0&lt;/em&gt; is the question a truth table answers for you.&lt;/p&gt;

&lt;p&gt;As a sample with &lt;script type=&quot;math/tex&quot;&gt;N=3&lt;/script&gt;, we will organize truth tables like this:&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;In1&lt;/th&gt;
      &lt;th&gt;In2&lt;/th&gt;
      &lt;th&gt;In3&lt;/th&gt;
      &lt;th&gt; &lt;/th&gt;
      &lt;th&gt;Out&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;All &lt;script type=&quot;math/tex&quot;&gt;N&lt;/script&gt; inputs come first, and the output is in the last column. This isn’t a particularly interesting function, as it always outputs the same thing, no matter what the input is. I like to call this function “a wire connected to +5V”.&lt;/p&gt;

&lt;p&gt;Let’s dig a bit deeper into some interesting functions. They don’t call them &lt;strong&gt;fun&lt;/strong&gt;ctions for nothing.&lt;/p&gt;

&lt;h2 id=&quot;fundamental-logic-functions&quot;&gt;Fundamental Logic Functions&lt;/h2&gt;

&lt;p&gt;Most of the basic boolean functions have particular names. There are 3 very basic ones that almost all lessons on boolean logic will start with: AND, OR, and NOT.&lt;/p&gt;

&lt;p&gt;Whoever came up with the names deserves a snickers bar, because the names actually make a ton of sense.&lt;/p&gt;

&lt;h3 id=&quot;not&quot;&gt;NOT&lt;/h3&gt;

&lt;p&gt;The simplest boolean function of interest to us has only &lt;script type=&quot;math/tex&quot;&gt;N=1&lt;/script&gt; inputs, which means there are two possible output states.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;In1&lt;/th&gt;
      &lt;th&gt; &lt;/th&gt;
      &lt;th&gt;Out&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;As you can see, NOT performs an &lt;em&gt;inversion&lt;/em&gt; of the boolean state. 1 is not 0, and 0 is not 1.&lt;/p&gt;

&lt;p&gt;When you are writing an equation, you’ll generally use capital letters like &lt;script type=&quot;math/tex&quot;&gt;A&lt;/script&gt; or &lt;script type=&quot;math/tex&quot;&gt;B&lt;/script&gt; or &lt;script type=&quot;math/tex&quot;&gt;X&lt;/script&gt; or &lt;script type=&quot;math/tex&quot;&gt;Y&lt;/script&gt; to indicate a variable which is boolean, and can take on 1 or 0 values.&lt;/p&gt;

&lt;p&gt;For hopefully obvious reasons, the letters &lt;script type=&quot;math/tex&quot;&gt;I&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;O&lt;/script&gt; are poor choices for boolean variable names.&lt;/p&gt;

&lt;p&gt;If we assume that &lt;script type=&quot;math/tex&quot;&gt;A&lt;/script&gt; is our input, and &lt;script type=&quot;math/tex&quot;&gt;B&lt;/script&gt; is our output, we would denote the NOT function as the following:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;B = \overline{A}&lt;/script&gt;

&lt;p&gt;This is to say that &lt;script type=&quot;math/tex&quot;&gt;B&lt;/script&gt; is the logical “NOT” of &lt;script type=&quot;math/tex&quot;&gt;A&lt;/script&gt;. Or, another way, to calculate &lt;script type=&quot;math/tex&quot;&gt;B&lt;/script&gt;, you invert &lt;script type=&quot;math/tex&quot;&gt;A&lt;/script&gt;.&lt;/p&gt;

&lt;h3 id=&quot;and&quot;&gt;AND&lt;/h3&gt;

&lt;p&gt;AND is another fundamental function, but it takes two inputs, implying that there are four possible output states.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;In1&lt;/th&gt;
      &lt;th&gt;In2&lt;/th&gt;
      &lt;th&gt; &lt;/th&gt;
      &lt;th&gt;Out&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;As you can see, AND outputs a 1 &lt;em&gt;if and only if&lt;/em&gt; both inputs are 1. In all other cases, the output is 0.&lt;/p&gt;

&lt;p&gt;This is another great name for a function. The output is 1 if the first input is 1 &lt;strong&gt;and&lt;/strong&gt; the second input is 1.&lt;/p&gt;

&lt;p&gt;When you describe AND in an equation, you write it like multiplication. This means you might put a dot between the inputs, or maybe just write them next to each other. For example:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;C = A \cdot B&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;C = AB&lt;/script&gt;

&lt;p&gt;Both of these equations denote that &lt;script type=&quot;math/tex&quot;&gt;C&lt;/script&gt; is calculated as the logical AND of input variables &lt;script type=&quot;math/tex&quot;&gt;A&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;B&lt;/script&gt;&lt;/p&gt;

&lt;h3 id=&quot;or&quot;&gt;OR&lt;/h3&gt;

&lt;p&gt;OR is our last fundamental function. Like AND, it takes two inputs. Like AND, it is also fairly well named.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;In1&lt;/th&gt;
      &lt;th&gt;In2&lt;/th&gt;
      &lt;th&gt; &lt;/th&gt;
      &lt;th&gt;Out&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;You can see that OR outputs a 1 when &lt;em&gt;either&lt;/em&gt; of its inputs is true - that is to say the output is 1 if the first input is 1, or the second input is 1.&lt;/p&gt;

&lt;p&gt;Note that if both inputs are 1, the output remains 1 - this is a bit of a departure from how most folks interpret the word “or”. If your mom asked you “Do you want to go to Disney World or Universal Studios?” she probably wouldn’t be all that pleased if you said “Both!”. But ignoring this for now…&lt;/p&gt;

&lt;p&gt;When you describe OR in an equation, you write it like addition. This means you have to use a plus symbol. For example:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;C = A + B&lt;/script&gt;

&lt;p&gt;This is the way to denote that &lt;script type=&quot;math/tex&quot;&gt;C&lt;/script&gt; is calculated as the logical OR of inputs &lt;script type=&quot;math/tex&quot;&gt;A&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;B&lt;/script&gt;.&lt;/p&gt;

&lt;h2 id=&quot;equations-order-of-operations&quot;&gt;Equations, Order of Operations&lt;/h2&gt;

&lt;p&gt;As we’ve shown already, boolean operations can be indicated with equations, just like regular math. Similar to regular base-10 math, you use variables that take on the value of 1 or 0, constant 1’s and 0’s, equals signs, an order of operations (with parenthesis to change it)… most of what applies in normal math applies here too!&lt;/p&gt;

&lt;p&gt;For example, take the following equation:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;D = f(A,B,C) = A \cdot \overline{(B+C)}&lt;/script&gt;

&lt;p&gt;Let’s break this function named &lt;script type=&quot;math/tex&quot;&gt;f&lt;/script&gt; down into its components. Order of operations would dictate that you evaluate the inside of the parenthesis first. In this case, you first evaluate the OR of &lt;script type=&quot;math/tex&quot;&gt;B&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;C&lt;/script&gt;.&lt;/p&gt;

&lt;p&gt;The NOT bar is drawn over that whole quantity, so you calculate the NOT of the whole quantity &lt;script type=&quot;math/tex&quot;&gt;(B + C)&lt;/script&gt;. That is to say - you first calcualte &lt;script type=&quot;math/tex&quot;&gt;B&lt;/script&gt; OR &lt;script type=&quot;math/tex&quot;&gt;C&lt;/script&gt;, then invert the result.&lt;/p&gt;

&lt;p&gt;Finally, &lt;script type=&quot;math/tex&quot;&gt;A&lt;/script&gt; is AND’ed with the result of that calculation. This produces the result &lt;script type=&quot;math/tex&quot;&gt;D&lt;/script&gt;.&lt;/p&gt;

&lt;p&gt;In general, order of operations will be:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Interior of Parenthesis&lt;/li&gt;
  &lt;li&gt;NOT&lt;/li&gt;
  &lt;li&gt;AND&lt;/li&gt;
  &lt;li&gt;OR&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Note that the NOT operation of putting a bar over a variable (or many) is kinda like parenthesis, where you are inverting a set of variables. Generally it’s better to be more verbose in calculations, and ask questions if the notation is unclear.&lt;/p&gt;

&lt;p&gt;When writing these formulas down (on paper or in code), I always recommend &lt;a href=&quot;https://en.wiktionary.org/wiki/go_the_whole_hog&quot;&gt;to go whole hog&lt;/a&gt; on parenthesis. If there’s even a slight chance order of operation might be ambiguous, put them en. Even if this is redundant, it’s always better to ensure you communicate your intention to the reader, or the compiler.&lt;/p&gt;

&lt;h3 id=&quot;properties-of-boolean-calculations&quot;&gt;Properties of Boolean Calculations&lt;/h3&gt;

&lt;p&gt;You may have heard certain terms from your math class like the “associative” property and the “communicative” property. I don’t like to get too stuck on terminology like this - it’s good to know it so you can communicate with others, but even more important you know the underlying concept. Suffice to say, for software writing’s sake, here’s a handful of useful ideas to keep in mind:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;The order of the inputs to AND and OR don’t matter. You can freely exchange inputs 1 and 2, and output is unchanged (inspect the truth tables, it’s easy to prove this by just looking at them). This can help you simplify calculations.&lt;/li&gt;
  &lt;li&gt;Any quantity ANDed with 1 will be itself, and any quantity ORed with 0 will be itself
    &lt;ul&gt;
      &lt;li&gt;This is often called the “identity” property. What it means is that if you see a &lt;script type=&quot;math/tex&quot;&gt;+0&lt;/script&gt; or &lt;script type=&quot;math/tex&quot;&gt;\cdot 1&lt;/script&gt; in an equation, you can trim it off without consequence. This is a useful fact when looking for ways to speed up a calculation.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Any quantity ANDed with 0 will be 0, and any quantity ORed with 1 will be 1
    &lt;ul&gt;
      &lt;li&gt;This is often called the “short circuit” property. What it means is that if you see a &lt;script type=&quot;math/tex&quot;&gt;+1&lt;/script&gt; or &lt;script type=&quot;math/tex&quot;&gt;\cdot 0&lt;/script&gt;, you don’t even have to bother doing the other half of the calculation, you already know the outcome. This is a &lt;em&gt;very&lt;/em&gt; useful fact when looking for ways to speed up a calculation.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;gates--drawing-diagrams&quot;&gt;Gates &amp;amp; Drawing Diagrams&lt;/h2&gt;

&lt;p&gt;Written out equations are not the only way to represent a binary equation. Indeed, this particular form of math has become strongly oriented toward creating real-world circuits which do useful things. As a result of that, it is common to represent a boolean calculation using a schematic or diagram, indicating how one could potentially create hardware to perform the associated calculation.&lt;/p&gt;

&lt;h3 id=&quot;logic-gates&quot;&gt;Logic Gates&lt;/h3&gt;

&lt;p&gt;The diagrams that are drawn indicate how entities called &lt;em&gt;logic gates&lt;/em&gt; will be hooked together to represent a whole circuit. A logic gate is an &lt;em&gt;abstraction&lt;/em&gt; of the electrical circuitry (probably involving transistors) which could implement the logic function represented.&lt;/p&gt;

&lt;p&gt;All of the fundamental operations we have mentioned so far have special symbols to indicate their identity.&lt;/p&gt;

&lt;h4 id=&quot;not-gate-symbol&quot;&gt;NOT Gate Symbol&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/assets/not.png&quot; alt=&quot;NOT Gate Symbol&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;and-gate-symbol&quot;&gt;AND Gate Symbol&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/assets/and.png&quot; alt=&quot;AND Gate Symbol&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;or-gate-symbol&quot;&gt;OR Gate Symbol&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/assets/or.png&quot; alt=&quot;OR Gate Symbol&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;logic-diagrams&quot;&gt;Logic Diagrams&lt;/h3&gt;

&lt;p&gt;When you combine multiple gates together, and hook them together in a particular way, you get what most folks will call a &lt;em&gt;logic diagram&lt;/em&gt; describing your boolean function.&lt;/p&gt;

&lt;p&gt;Take our previous simple example of a boolean function &lt;script type=&quot;math/tex&quot;&gt;f&lt;/script&gt;&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;D = f(A,B,C) = A \cdot \overline{(B+C)}&lt;/script&gt;

&lt;p&gt;Using our symbols, we can draw them together with function inputs and outputs, to graphically represent the same equation:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/simple_logic_diagram.png&quot; alt=&quot;Simple logic diagram&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Note how &lt;em&gt;information&lt;/em&gt; flows from left to right, just like you read. Your inputs are all on the left hand side, propagate through gates which transform and manipulate it, and eventually produce a single, final output on the right-hand side. This left-to-right flow convention is very commonly used in diagrams.&lt;/p&gt;

&lt;h2 id=&quot;2-level-logic&quot;&gt;2-Level Logic&lt;/h2&gt;

&lt;p&gt;As it turns out, all boolean functions, no matter how complex, can be broken down into a two-level hierarchy. This can be either a set of AND calculations OR’ed together, or a set of OR calculations AND’ed together. You may have to invert some of the inputs with NOT operations, but otherwise, it’s just two levels of gates.&lt;/p&gt;

&lt;p&gt;For software purposes, this is a useful fact to remember, but proving it is a bit more than what I’d want to get into in this post. Suffice to say, there are proofs that show arbitrarily large equations can be reduced into this manageable structure. Because of this, when analyzing or thinking about boolean logic, just keep in mind that two layers of gates is all that you will ever &lt;em&gt;need&lt;/em&gt;.&lt;/p&gt;

&lt;h2 id=&quot;derived-gates&quot;&gt;Derived Gates&lt;/h2&gt;

&lt;h3 id=&quot;xor&quot;&gt;XOR&lt;/h3&gt;

&lt;p&gt;There is a somewhat common gate called the “Exclusive OR” that calculates the more traditional “This or That (but not both)” meaning of the word “or”:&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;In1&lt;/th&gt;
      &lt;th&gt;In2&lt;/th&gt;
      &lt;th&gt; &lt;/th&gt;
      &lt;th&gt;Out&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;Another interpretation that’s often useful is that XOR outputs 1 when its inputs are &lt;em&gt;different&lt;/em&gt;, but 0 when they are the &lt;em&gt;same&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;There is an equation symbol for it, but it’s not commonly used.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;C = A \oplus B&lt;/script&gt;

&lt;p&gt;Indicates that C is the logical XOR of inputs A and B.&lt;/p&gt;

&lt;h3 id=&quot;nand-nor&quot;&gt;NAND, NOR&lt;/h3&gt;

&lt;p&gt;Finally, there are some additional gates which it’s good to be aware of:&lt;/p&gt;

&lt;h4 id=&quot;nand&quot;&gt;NAND:&lt;/h4&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;In1&lt;/th&gt;
      &lt;th&gt;In2&lt;/th&gt;
      &lt;th&gt; &lt;/th&gt;
      &lt;th&gt;Out&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;NAND, or “Not AND” is just that - it’s an AND gate, but with the output inverted.&lt;/p&gt;

&lt;h4 id=&quot;nor&quot;&gt;NOR&lt;/h4&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;In1&lt;/th&gt;
      &lt;th&gt;In2&lt;/th&gt;
      &lt;th&gt; &lt;/th&gt;
      &lt;th&gt;Out&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;NOR, or “Not OR” is just that - it’s an OR gate, but with the output inverted.&lt;/p&gt;

&lt;h4 id=&quot;symbols&quot;&gt;Symbols&lt;/h4&gt;

&lt;p&gt;Of course, there are symbols for these gates as well.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/xor_nor_nand.png&quot; alt=&quot;other gates symbols&quot; /&gt;&lt;/p&gt;

&lt;p&gt;From left to right, they are XOR, NOR, and NAND. Outputs are at the top, inputs are at the bottom.&lt;/p&gt;

&lt;p&gt;Note for NAND and NOR, the little circle on the output indicates the inversion operation. You may see that little circle elsewhere too - just know it implies “invert” on the signal it’s placed on.&lt;/p&gt;

&lt;h3 id=&quot;why-nandnor&quot;&gt;Why NAND/NOR&lt;/h3&gt;

&lt;p&gt;As it turns out, when you go look at the transistor configurations required to create normal AND/OR gates, they’re actually NAND/NOR with an inverter on the output. In terms of design optimization, it actually is easier to design the logic in terms of NAND/NOR, because you will use fewer transistors in the final design. This makes for cheaper, simpler, and more energy-efficient designs - all around a good thing!&lt;/p&gt;

&lt;p&gt;Even better - most modern electronics design tools can do the AND/OR to NAND/NOR transformation automatically for you, which means you can design in whatever set of gates is easiest for you to think about. Then the computer design tool can do the plug-and-chug to create a more efficient implementation.&lt;/p&gt;

&lt;p&gt;Furthermore, NAND and NOR have the interesting property of being able to emulate all the trivial gates themselves. Without a formal proof, and presented in pictures only, the evidence is presented below. Fun homework: Create a truth table for each of the below circuits to prove that they do in fact do what I claim they do.&lt;/p&gt;

&lt;h4 id=&quot;not-with-nand&quot;&gt;NOT with NAND:&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/assets/nand_not.png&quot; alt=&quot;NOT from Nand&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;and-with-nand&quot;&gt;AND with NAND:&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/assets/nand_and.png&quot; alt=&quot;AND from Nand&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;or-with-nand&quot;&gt;OR with NAND:&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/assets/nand_or.png&quot; alt=&quot;OR from Nand&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;so-what&quot;&gt;So what&lt;/h4&gt;

&lt;p&gt;Recall from further up that &lt;em&gt;any&lt;/em&gt; boolean function can be represented Here’s the additional punchline, as Professor Loui sang to us in ECE 101 (to the tune of the Beatles “All You Need is Love”) - “All you need is NAND… ba da da da da”. Only having to have one gate around can also help simplify designs sometimes - whether that’s a software tool that’s trying to create the most optimum configuration of transistors for your design, or whether you just don’t want to buy 10 types of circuit chips from &lt;a href=&quot;https://www.digikey.com&quot;&gt;Digikey&lt;/a&gt; for your project…. having just one gate type is often not a bad thing. Huzzah for standardization!&lt;/p&gt;

&lt;h2 id=&quot;further-study-in-boolean-logic&quot;&gt;Further Study in Boolean Logic&lt;/h2&gt;

&lt;h3 id=&quot;proofs--formal-math&quot;&gt;Proofs &amp;amp; Formal Math&lt;/h3&gt;

&lt;p&gt;If you spend some time looking through literature on this topic, you’ll find lots of formal proofs using axioms and things like “DeMorgan’s Law”. These are definitely good to take a peek through, but don’t have a ton of bearing on your ability to write good software. I’m also of the opinion that most of it is pretty self-evident if you stare at it long enough, to the point where it doesn’t make sense to do a formal introduction to them in this blog. As we get into discussing good coding techniques, these principles will naturally fall out.&lt;/p&gt;

&lt;h3 id=&quot;electronics&quot;&gt;Electronics&lt;/h3&gt;

&lt;p&gt;So, in case you were wondering, you can go out and buy logic gates! You will need to choose the right set of chips for the voltages you are using to represent 1 and 0. If you happen to go with the very-common answer of 5V = 1, 0V = 0, then Texas Instruments has for many many years made a beautiful line of &lt;a href=&quot;https://en.wikipedia.org/wiki/7400-series_integrated_circuits&quot;&gt;“74- series” chips&lt;/a&gt; which robustly implement logic gates in a cute little &lt;a href=&quot;https://en.wikipedia.org/wiki/Dual_in-line_package&quot;&gt;DIP package&lt;/a&gt;. Lots of other manufacturers make pin-compatible versions of them. If you’re starting off, I recommend getting a &lt;a href=&quot;https://www.amazon.com/Electronics-Salon-74HCxx-Assortment-High-Speed-Si-Gate/dp/B016ME1WH2/ref=sr_1_4?keywords=74+series+logic+kit&amp;amp;qid=1560517053&amp;amp;s=gateway&amp;amp;sr=8-4&quot;&gt;“variety pack”&lt;/a&gt; with spares of each to enable experimentation and play.&lt;/p&gt;

&lt;h2 id=&quot;next-steps---where-are-we-going&quot;&gt;Next Steps - Where are we going?&lt;/h2&gt;

&lt;p&gt;We’ve covered the basics of how bits can be combined and manipulated with fundamental logic gates. Moving forward, we’ll start to combine these gates into useful digital circuitry, building up to the main components of a computer processor.  Go check out &lt;a href=&quot;/blog_posts/2019/06/26/digital_devices.html&quot;&gt;Digital Devices&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Alternately, we’ll also cover some of the practical implications when building digital circuitry in the real world. For Extra Credit, check out &lt;a href=&quot;/blog_posts/2019/06/15/electronics_for_digital.html&quot;&gt;Electronics Part 2&lt;/a&gt;.&lt;/p&gt;</content><author><name></name></author><summary type="html">“All you need is NAND… ba da da da da” - Professor Michael Loui, 2010, UIUC</summary></entry><entry><title type="html">Binary</title><link href="/blog_posts/2019/06/10/binary.html" rel="alternate" type="text/html" title="Binary" /><published>2019-06-10T09:30:00-05:00</published><updated>2019-06-10T09:30:00-05:00</updated><id>/blog_posts/2019/06/10/binary</id><content type="html" xml:base="/blog_posts/2019/06/10/binary.html">&lt;h2 id=&quot;representing-ideas-with-symbols&quot;&gt;Representing Ideas with Symbols&lt;/h2&gt;

&lt;p&gt;Consider the following:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;16.&lt;/script&gt;

&lt;p&gt;When you read that, what did you think? You probably said “sixteen” in your head, assuming you think in English. This is a very good answer.&lt;/p&gt;

&lt;p&gt;What is “sixteen”, though? It’s a number, that’s for sure. It’s also an idea - a concept.&lt;/p&gt;

&lt;p&gt;Here’s what I think of when you say “sixteen”:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/sixteen.png&quot; alt=&quot;sixteen boxes&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Sixteen represents a quantity. There are sixteen boxes.&lt;/p&gt;

&lt;iframe src=&quot;https://giphy.com/embed/69rOXF4YTDVDD6cwkt&quot; width=&quot;480&quot; height=&quot;378&quot; frameborder=&quot;0&quot; class=&quot;giphy-embed&quot; allowfullscreen=&quot;&quot;&gt;&lt;/iframe&gt;
&lt;p&gt;&lt;a href=&quot;https://giphy.com/gifs/69rOXF4YTDVDD6cwkt&quot;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;No, Picard, there are 16 boxes.&lt;/p&gt;

&lt;p&gt;We are using the sequence of symbols &lt;script type=&quot;math/tex&quot;&gt;16&lt;/script&gt; to represent this quantity. You’re already very familiar with how this works, but it’s important to dig into the details - it will lead us to a natural way to define the binary system used in computers.&lt;/p&gt;

&lt;p&gt;There’s two things to take away from the symbol sequence &lt;script type=&quot;math/tex&quot;&gt;16.&lt;/script&gt;:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;It uses two symbols, &lt;script type=&quot;math/tex&quot;&gt;1&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;6&lt;/script&gt;, anchored around the decimal point &lt;script type=&quot;math/tex&quot;&gt;.&lt;/script&gt;&lt;/li&gt;
  &lt;li&gt;It puts them together in a particular order to give meaning to the quantity. &lt;script type=&quot;math/tex&quot;&gt;16.&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;61.&lt;/script&gt; are not the same.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;The number system we’re talking about is commonly referred to as the &lt;a href=&quot;https://en.wikipedia.org/wiki/Hindu%E2%80%93Arabic_numeral_system&quot;&gt;Hindu-Arabic number system&lt;/a&gt;. It was invented in India in the first century, and quickly its way through the Middle East and into Europe by the Middle Ages.&lt;/p&gt;

&lt;p&gt;It has a particular advantage over predicessor methods for representing numbers in two ways:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;There is a limited set of symbols to remember. For most modern mathematics, there are 10 symbols - &lt;script type=&quot;math/tex&quot;&gt;0&lt;/script&gt;, &lt;script type=&quot;math/tex&quot;&gt;1&lt;/script&gt;, &lt;script type=&quot;math/tex&quot;&gt;2&lt;/script&gt;, &lt;script type=&quot;math/tex&quot;&gt;3&lt;/script&gt;, &lt;script type=&quot;math/tex&quot;&gt;4&lt;/script&gt;, &lt;script type=&quot;math/tex&quot;&gt;5&lt;/script&gt;, &lt;script type=&quot;math/tex&quot;&gt;6&lt;/script&gt;, &lt;script type=&quot;math/tex&quot;&gt;7&lt;/script&gt;, &lt;script type=&quot;math/tex&quot;&gt;8&lt;/script&gt;, &lt;script type=&quot;math/tex&quot;&gt;9&lt;/script&gt;. Each represents a particular quantity.&lt;/li&gt;
  &lt;li&gt;The symbols are combined to represent quantities beyond the range of the symbol set. How it accomplishes this is really the &lt;a href=&quot;https://en.wikipedia.org/wiki/Secret_ingredient&quot;&gt;secret sauce&lt;/a&gt; to the whole system.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Each symbol is in some position relative to the “decimal point”. In English, we usually refer to them (from right to left) as the “ones place”, the “tens place”, the “hundreds place”, etc.&lt;/p&gt;

&lt;p&gt;Because there is a &lt;script type=&quot;math/tex&quot;&gt;1&lt;/script&gt; in the tens place, we multiply the quantity represented by &lt;script type=&quot;math/tex&quot;&gt;1&lt;/script&gt; by ten. Then, this quantity is added in with the quantity represented by &lt;script type=&quot;math/tex&quot;&gt;6&lt;/script&gt;, which because it is in the ones place, is multiplied by one (aka nothing is done to it). Together, ten and six make for a quantity of 16.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/sixteen_base_10.png&quot; alt=&quot;sixteen in base 10&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;the-concept-of-base&quot;&gt;The concept of “Base”&lt;/h3&gt;

&lt;p&gt;What’s the point of splitting like this? Note that any number in base 10 can be broken into a sum of its component digits.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;16 = 1*10 + 6*1&lt;/script&gt;

&lt;p&gt;This works, no matter how big the number gets.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;1736 = 1*1000 + 7*100 + 3*10 + 6*1&lt;/script&gt;

&lt;p&gt;Notice the pattern on the &lt;script type=&quot;math/tex&quot;&gt;*1000&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;*100&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;*10&lt;/script&gt; and such?&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;1736 = 1*10^{3} + 7*10^{2} + 3*10^{1} + 6*10^{0}&lt;/script&gt;

&lt;p&gt;Here’s the takeaway: in a positional number system, any quantity is represented by a sum of the digits, each multiplied by some “potency” factor associated with its position in the sequence.&lt;/p&gt;

&lt;p&gt;This is why we say we are using a &lt;em&gt;Base 10&lt;/em&gt; number system - the “base” of the number raised to some power to get the “potency” of each digit.&lt;/p&gt;

&lt;p&gt;You can create a generic formula using a summation:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;value = \sum_{i=0}^{i=N-1}D_i * 10^{i}&lt;/script&gt;

&lt;p&gt;Where&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;script type=&quot;math/tex&quot;&gt;N&lt;/script&gt; is the number of digits in the symbol sequence&lt;/li&gt;
  &lt;li&gt;&lt;script type=&quot;math/tex&quot;&gt;D_i&lt;/script&gt; is the &lt;script type=&quot;math/tex&quot;&gt;i&lt;/script&gt;‘th digit in the symbol sequence, with 0 being nearest the decimal point.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;But here’s the crucial question - &lt;em&gt;why is 10 the base&lt;/em&gt;?&lt;/p&gt;

&lt;p&gt;There’s lots of argument as to why it is the way it is - some say because you have 10 fingers. But the Mayans used base 20 (apparently they used their toes as well?), and the Babylonians used base 60 (???). Maybe the people who liked base 10 also happened to be the best at winning wars. For better or for worse, that’s how this sort of thing often gets decided.&lt;/p&gt;

&lt;p&gt;However, the takeaway you should have - &lt;em&gt;it doesn’t have to be 10&lt;/em&gt;. And indeed in designing computing systems, there are better answers.&lt;/p&gt;

&lt;h3 id=&quot;truefalse&quot;&gt;True/False&lt;/h3&gt;

&lt;p&gt;Back in the 1800’s there was this guy named &lt;a href=&quot;https://en.wikipedia.org/wiki/George_Boole&quot;&gt;George Boole&lt;/a&gt; was creating a mathematical computation for logical reasoning. Key to this line of thought was describing, associating, and combining the concepts of “True” and “False”. Two opposite fundamentals. Two. Hey, maybe Two is a good number.&lt;/p&gt;

&lt;p&gt;Two is also a nice “minimum viable product” for a set of symbols. Let’s think about what you can express using numbering systems that have varying numbers of symbols:&lt;/p&gt;

&lt;h4 id=&quot;the-zero-symbol-system&quot;&gt;The zero-symbol system&lt;/h4&gt;
&lt;p&gt;This system does not let you even write anything down. It is useless. Let us not waste another moment considering this.&lt;/p&gt;

&lt;h4 id=&quot;the-one-symbol-system&quot;&gt;The one-symbol system&lt;/h4&gt;
&lt;p&gt;This is effectively talley marks. Fair enough that it lets you start to express some ideas. However, you have to draw exactly the same number of symbols as the quantity you wish to express. You haven’t really gained anything here. If you already have sixteen boxes, do you need to draw sixteen lines somewhere to indicate that you have sixteen boxes? Seems sort of redundant. Why not just go out and count your boxes, and save the time of writing the talley marks? Maybe if you want to keep your own records. But then the other cavemen just make fun of you for being a nerd.&lt;/p&gt;

&lt;p&gt;Strictly speaking, this isn’t a positional number system, since the position doesn’t matter (&lt;script type=&quot;math/tex&quot;&gt;1^{anything} = 1&lt;/script&gt;).&lt;/p&gt;

&lt;p&gt;On the upside, addition just becomes string concatenation.&lt;/p&gt;

&lt;p&gt;We need to go one higher to realize the benefits of the positional number system.&lt;/p&gt;

&lt;h4 id=&quot;the-two-symbol-system&quot;&gt;The two-symbol system&lt;/h4&gt;

&lt;p&gt;Let’s use this one.&lt;/p&gt;

&lt;h3 id=&quot;truefalse-in-circuitry&quot;&gt;True/False in Circuitry&lt;/h3&gt;

&lt;p&gt;Unfortunately for Boole, electricity wasn’t fully understood yet - certainly not to the point where people were looking for creative ways to harness it. The “algebra of logic” portion of his work didn’t realize its full potential during his lifetime. It wasn’t till the 1930’s that another fellow by the name of &lt;a href=&quot;https://en.wikipedia.org/wiki/Claude_Shannon&quot;&gt;Claude Shannon&lt;/a&gt; realized that these True/False concepts could be mapped to voltages and currents, and controlled be switches. As part of his Masters thesis, he showed circuitry that could perform the calculations described by Boole and his contemporaries.&lt;/p&gt;

&lt;p&gt;The idea was extremely valuable. Perhaps not revolutionary - folks had been fiddling with analog devices that could do math, and later attempted trinary (base 3) and other exotic computer formats. However, the simplicity of designing circuits which only interpret “Voltage” or “No Voltage” has made such two-state designs far superior to any other option. Especially after the invention of the consumer-ready transistor later in the 1940s and 50s, true/false was here to stay.&lt;/p&gt;

&lt;p&gt;For this reason, almost all modern computers do math and logic using a base-2 system.&lt;/p&gt;

&lt;p&gt;Until we get to quantum computing. At which point, I’ll have to write another blog post.&lt;/p&gt;

&lt;h2 id=&quot;math-and-conversions-in-binary&quot;&gt;Math and Conversions in Binary&lt;/h2&gt;

&lt;p&gt;The formula for a number’s value is:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;value = \sum_{i=0}^{i=N-1}D_i * B^{i}&lt;/script&gt;

&lt;p&gt;Where&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;script type=&quot;math/tex&quot;&gt;N&lt;/script&gt; is the number of digits in the symbol sequence&lt;/li&gt;
  &lt;li&gt;&lt;script type=&quot;math/tex&quot;&gt;D_i&lt;/script&gt; is the &lt;script type=&quot;math/tex&quot;&gt;i&lt;/script&gt;‘th digit in the symbol sequence, with 0 being nearest the decimal point.&lt;/li&gt;
  &lt;li&gt;&lt;script type=&quot;math/tex&quot;&gt;B&lt;/script&gt; is the “base” of the number system.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Since we’re using base-2, the formula becomes&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;value = \sum_{i=0}^{i=N}D_i * 2^{i}&lt;/script&gt;

&lt;p&gt;Let’s take a quick example of a binary number:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;10010.&lt;/script&gt;

&lt;p&gt;Note the trailing &lt;script type=&quot;math/tex&quot;&gt;.&lt;/script&gt; for the anchor point - usually it’s left off, so we’ll start to do that here.&lt;/p&gt;

&lt;p&gt;What quantity is &lt;script type=&quot;math/tex&quot;&gt;10010&lt;/script&gt; ? let’s plug and chug with our formula from above. The summation would unroll to:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;value = 1*2^{4} + 0*2^{3} + 0*2^{2} + 1*2^{1} + 0*2^{0}&lt;/script&gt;

&lt;p&gt;Which simplifies down to:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;value = 2^{4} + 2^{1} = 16+2 = 18&lt;/script&gt;

&lt;p&gt;There we go! A first conversion from binary to base 10!&lt;/p&gt;

&lt;p&gt;If you want to go back the other way, all you have to do is decompose a base-10 number into powers of two. I’ll just write out the algorithm here, and then leave it as an exercise to the reader to attempt:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Start with your number being the number to convert.&lt;/li&gt;
  &lt;li&gt;Find the largest position &lt;script type=&quot;math/tex&quot;&gt;i&lt;/script&gt; such that &lt;script type=&quot;math/tex&quot;&gt;2^i&lt;/script&gt; is &lt;em&gt;equal to or less than&lt;/em&gt; your number&lt;/li&gt;
  &lt;li&gt;Place a 1 in this position.&lt;/li&gt;
  &lt;li&gt;Subtract 1 from &lt;script type=&quot;math/tex&quot;&gt;i&lt;/script&gt;., subtract &lt;script type=&quot;math/tex&quot;&gt;2^i&lt;/script&gt; from your number.&lt;/li&gt;
  &lt;li&gt;If &lt;script type=&quot;math/tex&quot;&gt;i&lt;/script&gt; is not yet zero, go to step 1.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;What I find super slick about this is that since binary is also a positional number system, just like the base-10 one you’re used to, all the arithmetic tricks and algorithms you learned in first through third grade still apply! Adding by lining up the digits, carrying spill-over to the next place, subtraction with borrowing, even long division - they all still work!&lt;/p&gt;

&lt;h3 id=&quot;a-note-on-notation&quot;&gt;A note on Notation&lt;/h3&gt;

&lt;p&gt;There are a lot of notations used “out in the wild” to indicate what base number system you are using. If you see a number, it’s sometimes safe to assume base 10, but sometimes not.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;There are 10 types of people in the world. Ones who understand binary, and ones who don’t&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Let’s not let this T-shirt prophecy come true.&lt;/p&gt;

&lt;p&gt;Little subscripts on a number indicate it’s base. So &lt;script type=&quot;math/tex&quot;&gt;10_{10}&lt;/script&gt; is Ten. &lt;script type=&quot;math/tex&quot;&gt;10_{2}&lt;/script&gt; is Two. &lt;script type=&quot;math/tex&quot;&gt;100_{10}&lt;/script&gt; is one hundred, while &lt;script type=&quot;math/tex&quot;&gt;100_{2}&lt;/script&gt; is four. Obviously, something like &lt;script type=&quot;math/tex&quot;&gt;4523_{2}&lt;/script&gt; is nonsense and meaningless, and you should tell the author right away so they can correct their error.&lt;/p&gt;

&lt;h2 id=&quot;representing-ideas-with-bytes&quot;&gt;Representing Ideas with Bytes&lt;/h2&gt;

&lt;p&gt;We’ve shown how 1’s and 0’s can be assembled together to represent positive integers so far. This is a very very common usage within computing, and in general is the one processors are built around. However, there are a number of other options for interpreting a string of 1’s and 0’s.&lt;/p&gt;

&lt;h3 id=&quot;truefalse-1&quot;&gt;True/False&lt;/h3&gt;

&lt;p&gt;We’ve already mentioned this, but the most straightforward mapping of 1’s and 0’s to some concept is simply true and false.&lt;/p&gt;

&lt;p&gt;Usually,&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;1 -&amp;gt; True -&amp;gt; “ON”&lt;/li&gt;
  &lt;li&gt;0 -&amp;gt; False -&amp;gt; “OFF”&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;We’ll show later the reason why this interpretation is particularly powerful for making decisions and calculation.&lt;/p&gt;

&lt;p&gt;Just like a single base-10 number is often called a “digit”, a single boolean 1 or 0 is called  &lt;em&gt;bit&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&quot;positive-integers-continued&quot;&gt;Positive Integers (continued)&lt;/h3&gt;

&lt;h4 id=&quot;vocabulary&quot;&gt;Vocabulary&lt;/h4&gt;

&lt;p&gt;Also as we just showed above, positive integers can be calculated by treating 1’s and 0’s as a base-2 number system. This covers a big chunk of the things we want to represent.&lt;/p&gt;

&lt;p&gt;It’s also convenient to group sets of 4, 8, 16, 32, or 64 bits into integers to keep track of them easier - even if you are not necessarily trying to represent a number. It’s all 1’s and 0’s at the end of the day, so whatever representation makes life easiest, use that one!&lt;/p&gt;

&lt;p&gt;In general, 8 bits is referred to as a &lt;em&gt;byte&lt;/em&gt;. Because computer scientists are often cute, they call 4 bits a &lt;em&gt;nibble&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Most modern computers work will do computation on more than one byte at a time. A &lt;em&gt;word&lt;/em&gt; is a set of one or more bytes, which the computer works on at the same time.&lt;/p&gt;

&lt;p&gt;Within a word, bits must be ordered. The bit closest to the “anchor point” in the “ones” position, is called the &lt;em&gt;Least Significant Bit&lt;/em&gt; or &lt;em&gt;LSB&lt;/em&gt;. The bit at the opposite end, furthest from the decimal point, is called the &lt;em&gt;Most Significant Bit&lt;/em&gt; or &lt;em&gt;MSB&lt;/em&gt; or &lt;em&gt;leading bit&lt;/em&gt;. Note that similar acronyms are also applied to the first and last byte of a word, so you may need some context to figure out what the author refers to. Capital letter B often means byte, lower-case letter b often means bit.&lt;/p&gt;

&lt;h4 id=&quot;historical-perspective-on-byte-width&quot;&gt;Historical Perspective on Byte Width&lt;/h4&gt;

&lt;p&gt;Tiny embedded processors are often still 8-bit (one-byte word). For many years, 32-bit computers (4-byte words) were the standard. Within the last few years 64-bit (8-byte) words has become standard. Later blog posts will delve further into exactly what this implies, but for now just think of it as “how many bits can the computer work on at once”.&lt;/p&gt;

&lt;p&gt;Special-purpose computers can have more exotic word-sizes. The older &lt;a href=&quot;https://en.wikipedia.org/wiki/Nintendo_64&quot;&gt;Nintendo 64 gaming console&lt;/a&gt; was one of the first instances of using 64-bit processors in consumer devices, and that was back in the early 1990’s. Even before that, 24 bit processors were common in some audio applications, as 24 bits was considered “good enough” to represent audio that humans could hear. Graphics processing frequently goes big - some bleeding edge graphics cards have parts that work on 512 bits at a time!.&lt;/p&gt;

&lt;p&gt;If you use every bit in a word to represent a positive integer, there is a fixed range of numbers you can represent. All bits off of course corresponds to a value of &lt;script type=&quot;math/tex&quot;&gt;0&lt;/script&gt;. For an &lt;script type=&quot;math/tex&quot;&gt;N&lt;/script&gt; bit word, all bits on represents a value of &lt;script type=&quot;math/tex&quot;&gt;2^{N} - 1&lt;/script&gt; (proof left as exercise to the reader). For example, a 32-bit integer can represent values between 0 and 4294967295. It’s a really big range, but it’s not without its limits!&lt;/p&gt;

&lt;p&gt;When you treat a set of bits as only positive integers, you are said to be doing &lt;em&gt;unsigned math&lt;/em&gt;.&lt;/p&gt;

&lt;h3 id=&quot;negative-integers&quot;&gt;Negative Integers&lt;/h3&gt;

&lt;p&gt;Representing negative numbers in a nice way is a bit of a challenge. The truth is you could pick any scheme you want to map sequences of 1’s and 0’s to numbers, but you want to do it in a way that makes calculation easy. If you had to hard code every &lt;script type=&quot;math/tex&quot;&gt;X-Y&lt;/script&gt; combination into your software, you’d get tired and frustrated pretty fast. A healthy dose of laziness is the mark of a good engineer.&lt;/p&gt;

&lt;p&gt;The good news is that the most commonly used system is pretty darn good. It’s called &lt;a href=&quot;https://en.wikipedia.org/wiki/Two%27s_complement&quot;&gt;&lt;em&gt;Two’s Compliment&lt;/em&gt;&lt;/a&gt;. We won’t delve too much into it, but suffice to say it has the following properties:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;The Most Significant Bit represents the sign of the number. 0 means positive, 1 means negative.&lt;/li&gt;
  &lt;li&gt;When the leading bit is 0, bits are interpreted the same way as unsigned integers.&lt;/li&gt;
  &lt;li&gt;When the leading bit is 1, for an N bit number, the value is equal to &lt;script type=&quot;math/tex&quot;&gt;(-1) * 2^{N} + X&lt;/script&gt; where &lt;script type=&quot;math/tex&quot;&gt;X&lt;/script&gt; is the unsigned value of the first &lt;script type=&quot;math/tex&quot;&gt;N-1&lt;/script&gt; bits.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Therefor, a 2’s complement number will have range &lt;script type=&quot;math/tex&quot;&gt;(-1) * 2^{N-1}&lt;/script&gt; to &lt;script type=&quot;math/tex&quot;&gt;2^{N-1} - 1&lt;/script&gt;. Proof is again left as an exercise to the reader.&lt;/p&gt;

&lt;p&gt;For example, when &lt;script type=&quot;math/tex&quot;&gt;N=8&lt;/script&gt;,&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Base 2&lt;/th&gt;
      &lt;th&gt;Base 10&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;01111111&lt;/td&gt;
      &lt;td&gt;127&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;01111110&lt;/td&gt;
      &lt;td&gt;126&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;…&lt;/td&gt;
      &lt;td&gt;…&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;00000010&lt;/td&gt;
      &lt;td&gt;2&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;00000001&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;00000000&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;11111111&lt;/td&gt;
      &lt;td&gt;-1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;11111110&lt;/td&gt;
      &lt;td&gt;-2&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;…&lt;/td&gt;
      &lt;td&gt;…&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;10000001&lt;/td&gt;
      &lt;td&gt;-127&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;10000000&lt;/td&gt;
      &lt;td&gt;-128&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;The key advantage of doing it this way is spelled out in more detail on wikipedia. In short - addition and subtraction &lt;em&gt;just work&lt;/em&gt;, without anything special. If you add up -1 and 1, and allow for the carried bit to “fall off” the end of the 8 bit calculation, you get 0.&lt;/p&gt;

&lt;p&gt;As you maybe already see, the 2’s compliment pattern is technically circular when the bit width is fixed (as it is in all processors). When you are working with 8 bit integers, and add 1 to 127, in bits, you get &lt;script type=&quot;math/tex&quot;&gt;01111111_2 + 00000001_2 = 10000000_2 = -128_{10}&lt;/script&gt;. This is often called &lt;em&gt;overflow&lt;/em&gt; or &lt;em&gt;wraparound&lt;/em&gt;. It’s unintuitive at first, but usually indicates a problem with your software - adding two positive numbers should not create a negative one. Some processors can detect this and raise an alarm.&lt;/p&gt;

&lt;p&gt;When writing software and designing hardware, use caution when depending on rollover behavior. It’s not always obvious without sufficient documentation, and if anyone accidentally changes variable bit width in the future, they’ll be in for a world of hurt figuring out why the code doesn’t work anymore.&lt;/p&gt;

&lt;p&gt;When you treat a set of bits as 2’s compliment integers, you are said to be doing &lt;em&gt;signed math&lt;/em&gt;.&lt;/p&gt;

&lt;h3 id=&quot;fractional-numbers&quot;&gt;Fractional Numbers&lt;/h3&gt;

&lt;p&gt;Most engineering values in the real world aren’t nice round integers. We need a way to represent some value like &lt;script type=&quot;math/tex&quot;&gt;1.4623&lt;/script&gt;. In broad strokes, there are two ways this is accomplished.&lt;/p&gt;

&lt;h4 id=&quot;fixed-point&quot;&gt;Fixed Point&lt;/h4&gt;

&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Fixed-point_arithmetic&quot;&gt;Fixed Point&lt;/a&gt; is largely the historical way that fractional numbers were represented. There’s some more formal math that goes into it, but the best way I know to think of it is that each “bit” represents some fraction of an engineering unit. For example, you could say that a particular variable is scaled at “0.25 RPM per Bit”, implying that the real-world engineering value is always equal to 1/4th the value of the integer you read in software.&lt;/p&gt;

&lt;p&gt;This makes it very easy to store a fraction - it’s no different than a normal integer. The only thing to be careful of is when you store, read, or perform math with the stored value - you have to be careful to build in additional conversion factors to make your formulas work properly.&lt;/p&gt;

&lt;p&gt;This small bit of extra math can easily be optimized at build time though, so the method is still quite low overhead at runtime. For this reason, it’s usually the best choice when execution speed is of the utmost importance on resource-limited embedded processors.&lt;/p&gt;

&lt;p&gt;As you can probably see, there is an obvious limit to the size of the “step” you can represent. In our above example, we can exactly represent a reading of 7.75 RPM, but not 7.8 RPM. The more granularity you desire, the less min/max range you get.&lt;/p&gt;

&lt;h4 id=&quot;floating-point&quot;&gt;Floating Point&lt;/h4&gt;

&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Floating-point_arithmetic&quot;&gt;Floating Point&lt;/a&gt; is the “newer” way to represent fractional numbers. Floating Point is covered by &lt;a href=&quot;https://en.wikipedia.org/wiki/Institute_of_Electrical_and_Electronics_Engineers&quot;&gt;IEEE&lt;/a&gt; &lt;a href=&quot;https://en.wikipedia.org/wiki/Double-precision_floating-point_format&quot;&gt;standards documents&lt;/a&gt;, which show how to split a number into an exponential representation, then pack it into bits. Again, the mapping is chosen carefully to make the math easy to do while a program is executing.&lt;/p&gt;

&lt;p&gt;Floating point is still pretty complex to do by hand. Most modern processors include hardware units to support doing the math. These are not quite as fast as doing integer math, but are far faster than doing it “long hand” within your software implementation.&lt;/p&gt;

&lt;p&gt;Due to the proliferation of floating point support in hardware, it’s becoming more and more the standard for how to do engineering math in embedded systems. For FRC robotics purposes, I would recommend using it. Only in cases of extreme optimization does it make sense to go back to using fixed point (or other) representations. However, keep in mind that it does bear a small performance penalty - try not to use floating point math for doing things like counting, where the fractional portion will never be needed.&lt;/p&gt;

&lt;h3 id=&quot;letters&quot;&gt;Letters&lt;/h3&gt;

&lt;p&gt;Beyond numbers, there are a lot of other things you might want to represent. Letters are a common one - any time you print something to console, you have to represent a string of characters that forms English words that some human can understand quickly.&lt;/p&gt;

&lt;p&gt;To do this, there was again a &lt;a href=&quot;https://en.wikipedia.org/wiki/ASCII&quot;&gt;standard, called ASCII,&lt;/a&gt; put together to map sequences of bits to letters in the alphabet. They started with just the common English/Latin characters, plus a handful of helper symbols and codes designed around how typewriters printed out letters (see &lt;a href=&quot;https://en.wikipedia.org/wiki/Carriage_return&quot;&gt;Carriage Return&lt;/a&gt; and &lt;a href=&quot;https://en.wikipedia.org/wiki/Newline&quot;&gt;Line Feed&lt;/a&gt;). Later standards like &lt;a href=&quot;https://en.wikipedia.org/wiki/UTF-8&quot;&gt;UTF-8&lt;/a&gt; and similar expanded upon this, and &lt;a href=&quot;https://xkcd.com/1726/&quot;&gt;continue to expand&lt;/a&gt; to get more and more languages and systems of writing represented and displayed in computer systems.&lt;/p&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;We’ve done an overview of some of the methods used to map 1’s and 0’s to various ideas. Going forward, just keep in mind that there exists a number of ways to transform a sequence of 1’s and 0’s into numbers, fractions, letters, and beyond.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;There are 10 types of people in the world. Ones who understand binary, ones who don’t, and ones who don’t expect base-3&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&quot;next-steps---where-are-we-going&quot;&gt;Next Steps - Where are we going?&lt;/h2&gt;

&lt;p&gt;We know some basics about the nature of 1’s and 0’s. Next, we’ll learn how to combine them together. Check out &lt;a href=&quot;/blog_posts/2019/06/14/boolean_logic.html&quot;&gt;Boolean Logic&lt;/a&gt; for more details!&lt;/p&gt;</content><author><name></name></author><summary type="html">Representing Ideas with Symbols</summary></entry></feed>